<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>âœ¨ Galaxy Christmas Tree âœ¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: 'Times New Roman', Georgia, serif;
        }

        #container {
            width: 100vw;
            height: 100vh;
        }

        .text-overlay {
            position: fixed;
            left: 8%;
            top: 38%;
            pointer-events: none;
            z-index: 10;
        }

        .text-overlay h1 {
            font-size: clamp(32px, 5vw, 56px);
            font-style: italic;
            font-weight: normal;
            color: rgba(255, 255, 255, 0.9);
            text-shadow:
                0 0 30px rgba(255, 255, 255, 0.4),
                0 0 60px rgba(255, 200, 220, 0.2);
            margin-bottom: 12px;
            animation: float 4s ease-in-out infinite;
        }

        .text-overlay p {
            font-size: clamp(20px, 3vw, 32px);
            font-family: 'KaiTi', 'æ¥·ä½“', 'STKaiti', serif;
            color: rgba(255, 210, 225, 0.85);
            text-shadow:
                0 0 20px rgba(255, 150, 180, 0.4),
                0 0 40px rgba(255, 100, 150, 0.2);
            animation: float 4s ease-in-out infinite 0.5s;
        }

        @keyframes float {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-6px);
            }
        }

        /* å¼€åœºè¦†ç›–å±‚ */
        #intro-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }

        /* å‘¼å¸å…‰åœˆ */
        .breath-ring {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            animation: breathe 2s ease-in-out infinite;
            position: relative;
        }

        .breath-ring::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            animation: breathe 2s ease-in-out infinite;
        }

        .breath-ring::after {
            content: '';
            position: absolute;
            top: -20px;
            left: -20px;
            right: -20px;
            bottom: -20px;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.15);
            animation: breathe 2s ease-in-out infinite 0.3s;
        }

        @keyframes breathe {

            0%,
            100% {
                transform: scale(1);
                opacity: 0.3;
            }

            50% {
                transform: scale(1.2);
                opacity: 0.8;
            }
        }

        .breath-ring::before {
            animation: breathe-inner 2s ease-in-out infinite;
        }

        @keyframes breathe-inner {

            0%,
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.4;
            }

            50% {
                transform: translate(-50%, -50%) scale(1.3);
                opacity: 1;
            }
        }

        /* æ–‡å­—åˆå§‹éšè— */
        .text-overlay.hidden {
            opacity: 0;
        }

        .text-overlay {
            transition: opacity 1.5s ease-in-out;
        }
    </style>
</head>

<body>
    <div id="container"></div>
    <div class="text-overlay hidden">
        <h1>Merry Christmas</h1>
        <p>æˆ‘çˆ±ä½ ï¼Œå®è´</p>
    </div>

    <!-- å¼€åœºè¦†ç›–å±‚ -->
    <div id="intro-overlay">
        <div class="breath-ring"></div>
    </div>

    <!-- è°ƒè¯•é¢æ¿ (æŒ‰` é”®åˆ‡æ¢) -->
    <div id="debug-info" style="
        display: none;
        position: fixed;
        top: 20px;
        right: 20px;
        background: rgba(0,0,0,0.85);
        color: #0f0;
        padding: 15px;
        font-family: monospace;
        font-size: 13px;
        border-radius: 8px;
        z-index: 1000;
        max-height: 90vh;
        overflow-y: auto;
        width: 280px;
    ">
        <div id="camera-info"></div>
        <hr style="border-color:#333; margin:10px 0;">

        <b>ğŸ¬ åŠ¨ç”»å‚æ•°</b><br><br>

        <label>èµ·ç‚¹ X: <input type="number" id="anim-start-x" step="0.1"
                style="width:60px; background:#222; color:#0f0; border:1px solid #444;"></label>
        <button onclick="setStartToCurrent()" style="margin-left:5px; font-size:11px;">å½“å‰</button><br>
        <label>èµ·ç‚¹ Y: <input type="number" id="anim-start-y" step="0.1"
                style="width:60px; background:#222; color:#0f0; border:1px solid #444;"></label><br>
        <label>èµ·ç‚¹ Z: <input type="number" id="anim-start-z" step="0.1"
                style="width:60px; background:#222; color:#0f0; border:1px solid #444;"></label><br><br>

        <label>ç»ˆç‚¹ X: <input type="number" id="anim-end-x" step="0.1"
                style="width:60px; background:#222; color:#0f0; border:1px solid #444;"></label>
        <button onclick="setEndToCurrent()" style="margin-left:5px; font-size:11px;">å½“å‰</button><br>
        <label>ç»ˆç‚¹ Y: <input type="number" id="anim-end-y" step="0.1"
                style="width:60px; background:#222; color:#0f0; border:1px solid #444;"></label><br>
        <label>ç»ˆç‚¹ Z: <input type="number" id="anim-end-z" step="0.1"
                style="width:60px; background:#222; color:#0f0; border:1px solid #444;"></label><br>

        <hr style="border-color:#333; margin:10px 0;">
        <b>ğŸ¯ ç›®æ ‡ç‚¹ (æ—‹è½¬ä¸­å¿ƒ)</b><br><br>

        <label>èµ·å§‹ç›®æ ‡ X: <input type="number" id="anim-target-start-x" step="0.1"
                style="width:50px; background:#222; color:#ff0; border:1px solid #444;"></label><br>
        <label>èµ·å§‹ç›®æ ‡ Y: <input type="number" id="anim-target-start-y" step="0.1"
                style="width:50px; background:#222; color:#ff0; border:1px solid #444;"></label><br>
        <label>èµ·å§‹ç›®æ ‡ Z: <input type="number" id="anim-target-start-z" step="0.1"
                style="width:50px; background:#222; color:#ff0; border:1px solid #444;"></label><br><br>

        <label>ç»“æŸç›®æ ‡ X: <input type="number" id="anim-target-end-x" step="0.1"
                style="width:50px; background:#222; color:#ff0; border:1px solid #444;"></label><br>
        <label>ç»“æŸç›®æ ‡ Y: <input type="number" id="anim-target-end-y" step="0.1"
                style="width:50px; background:#222; color:#ff0; border:1px solid #444;"></label><br>
        <label>ç»“æŸç›®æ ‡ Z: <input type="number" id="anim-target-end-z" step="0.1"
                style="width:50px; background:#222; color:#ff0; border:1px solid #444;"></label><br>

        <hr style="border-color:#333; margin:10px 0;">

        <label>æ—¶é•¿(ç§’): <input type="number" id="anim-duration" step="0.1" min="0.5" max="10"
                style="width:60px; background:#222; color:#0f0; border:1px solid #444;"></label><br><br>

        <label>ç¼“åŠ¨å‡½æ•°:
            <select id="anim-easing" style="background:#222; color:#0f0; border:1px solid #444;">
                <option value="linear">linear (çº¿æ€§)</option>
                <option value="easeOut" selected>easeOutCubic (ç¼“å‡º)</option>
                <option value="easeIn">easeInCubic (ç¼“å…¥)</option>
                <option value="easeInOut">easeInOutCubic (ç¼“å…¥ç¼“å‡º)</option>
            </select>
        </label><br><br>

        <button onclick="replayAnimation()"
            style="padding:8px 16px; background:#0a0; color:#000; border:none; border-radius:4px; cursor:pointer; font-weight:bold;">
            â–¶ é‡æ’­åŠ¨ç”»
        </button>
        <button onclick="printParams()"
            style="padding:8px 12px; background:#333; color:#0f0; border:1px solid #0f0; border-radius:4px; cursor:pointer; margin-left:5px;">
            ğŸ“‹ è¾“å‡º
        </button>

        <hr style="border-color:#333; margin:10px 0;">
        <b>ğŸ¥ å½•åˆ¶åŠ¨ç”»</b><br>
        <span style="color:#888; font-size:11px;">
            æŒ‰ <kbd style="background:#444; padding:2px 5px; border-radius:3px;">R</kbd> å¼€å§‹å½•åˆ¶<br>
            æ‹–åŠ¨æ‘„åƒå¤´ï¼Œæ¾å¼€é¼ æ ‡ç»“æŸ
        </span>
        <div id="record-status" style="color:#f00; margin-top:5px;"></div>

        <hr style="border-color:#333; margin:10px 0;">
        <b>ğŸ“ æ–‡å­—é…ç½®</b><br><br>

        <label>ä½ç½® Left: <input type="text" id="text-left" value="8%"
                style="width:50px; background:#222; color:#0f0; border:1px solid #444;"></label><br>
        <label>ä½ç½® Top: <input type="text" id="text-top" value="38%"
                style="width:50px; background:#222; color:#0f0; border:1px solid #444;"></label><br><br>

        <div id="text-lines-config">
            <div class="text-line-config" data-line="0">
                <b style="color:#ff0;">è¡Œ1:</b><br>
                <input type="text" id="text-content-0" value="Merry Christmas"
                    style="width:150px; background:#222; color:#0f0; border:1px solid #444;"><br>
                <label style="font-size:11px;">å­—å·: <input type="text" id="text-size-0" value="clamp(32px, 5vw, 56px)"
                        style="width:100px; background:#222; color:#888; border:1px solid #333;"></label><br>
                <label style="font-size:11px;">é¢œè‰²: <input type="text" id="text-color-0" value="rgba(255,255,255,0.9)"
                        style="width:100px; background:#222; color:#888; border:1px solid #333;"></label><br>
                <label style="font-size:11px;">æ–œä½“: <input type="checkbox" id="text-italic-0" checked></label>
                <label style="font-size:11px; margin-left:10px;">å­—ä½“:
                    <select id="text-font-0"
                        style="background:#222; color:#888; border:1px solid #333; font-size:10px;">
                        <option value="serif" selected>è¡¬çº¿ä½“</option>
                        <option value="sans-serif">æ— è¡¬çº¿</option>
                        <option value="KaiTi">æ¥·ä½“</option>
                    </select>
                </label>
            </div>
            <br>
            <div class="text-line-config" data-line="1">
                <b style="color:#ff0;">è¡Œ2:</b><br>
                <input type="text" id="text-content-1" value="æˆ‘çˆ±ä½ ï¼Œå®è´"
                    style="width:150px; background:#222; color:#0f0; border:1px solid #444;"><br>
                <label style="font-size:11px;">å­—å·: <input type="text" id="text-size-1" value="clamp(20px, 3vw, 32px)"
                        style="width:100px; background:#222; color:#888; border:1px solid #333;"></label><br>
                <label style="font-size:11px;">é¢œè‰²: <input type="text" id="text-color-1" value="rgba(255,210,225,0.85)"
                        style="width:100px; background:#222; color:#888; border:1px solid #333;"></label><br>
                <label style="font-size:11px;">æ–œä½“: <input type="checkbox" id="text-italic-1"></label>
                <label style="font-size:11px; margin-left:10px;">å­—ä½“:
                    <select id="text-font-1"
                        style="background:#222; color:#888; border:1px solid #333; font-size:10px;">
                        <option value="serif">è¡¬çº¿ä½“</option>
                        <option value="sans-serif">æ— è¡¬çº¿</option>
                        <option value="KaiTi" selected>æ¥·ä½“</option>
                    </select>
                </label>
            </div>
        </div>
        <br>
        <button onclick="applyTextConfig()"
            style="padding:6px 12px; background:#06a; color:#fff; border:none; border-radius:4px; cursor:pointer;">
            âœï¸ åº”ç”¨æ–‡å­—
        </button>
        <button onclick="printTextConfig()"
            style="padding:6px 10px; background:#333; color:#0f0; border:1px solid #0f0; border-radius:4px; cursor:pointer; margin-left:5px;">
            ğŸ“‹
        </button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        const container = document.getElementById('container');
        const scene = new THREE.Scene();

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
        // åˆå§‹ä½ç½®: ä¿¯è§†è§’åº¦ (ç¬¬ä¸€å¼ æˆªå›¾)
        camera.position.set(-1.7, 14.4, -2.2);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x000005, 1);
        container.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.rotateSpeed = 0.5;
        controls.enablePan = false;
        controls.minDistance = 5;
        controls.maxDistance = 50;
        controls.target.set(0, 6, 0);  // åˆå§‹ç›®æ ‡ç‚¹ï¼ˆä¿¯è§†æ—¶çœ‹å‘æ ‘é¡¶ï¼‰
        controls.enabled = false;  // åŠ¨ç”»å®Œæˆå‰ç¦ç”¨
        controls.update();

        // ============ æ‘„åƒå¤´åŠ¨ç”»çŠ¶æ€ ============
        let cameraAnimating = false;
        let cameraAnimProgress = 0;

        // åŠ¨ç”»å‚æ•°ï¼ˆå¯é€šè¿‡è°ƒè¯•é¢æ¿ä¿®æ”¹ï¼‰
        let animParams = {
            startX: -1.7, startY: 14.4, startZ: -2.2,
            endX: -6.4, endY: 4.4, endZ: 10.7,
            // ç›®æ ‡ç‚¹ï¼ˆæ—‹è½¬ä¸­å¿ƒï¼‰
            targetStartX: 0, targetStartY: 6, targetStartZ: 0,
            targetEndX: 0, targetEndY: 2, targetEndZ: 0,
            duration: 2.5,
            easing: 'easeOut'
        };

        // ç¼“åŠ¨å‡½æ•°é›†åˆ
        const easingFunctions = {
            linear: t => t,
            easeOut: t => 1 - Math.pow(1 - t, 3),
            easeIn: t => Math.pow(t, 3),
            easeInOut: t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2
        };

        // æåæ ‡è½¬æ¢ï¼šç¬›å¡å°” -> æåæ ‡ï¼ˆç›¸å¯¹äºç›®æ ‡ç‚¹ï¼‰
        function cartesianToSpherical(x, y, z, targetX, targetY, targetZ) {
            const dx = x - targetX;
            const dy = y - targetY;
            const dz = z - targetZ;
            const r = Math.sqrt(dx * dx + dy * dy + dz * dz);
            const theta = Math.atan2(dx, dz);  // æ–¹ä½è§’
            const phi = Math.acos(dy / r);     // ä»°è§’ï¼ˆä»Yè½´å‘ä¸‹ï¼‰
            return { r, theta, phi };
        }

        // æåæ ‡è½¬æ¢ï¼šæåæ ‡ -> ç¬›å¡å°”ï¼ˆç›¸å¯¹äºç›®æ ‡ç‚¹ï¼‰
        function sphericalToCartesian(r, theta, phi, targetX, targetY, targetZ) {
            const x = targetX + r * Math.sin(phi) * Math.sin(theta);
            const y = targetY + r * Math.cos(phi);
            const z = targetZ + r * Math.sin(phi) * Math.cos(theta);
            return { x, y, z };
        }

        function getEasing(t) {
            return easingFunctions[animParams.easing](t);
        }

        // åˆå§‹åŒ–è°ƒè¯•é¢æ¿è¾“å…¥æ¡†
        function initDebugPanel() {
            document.getElementById('anim-start-x').value = animParams.startX;
            document.getElementById('anim-start-y').value = animParams.startY;
            document.getElementById('anim-start-z').value = animParams.startZ;
            document.getElementById('anim-end-x').value = animParams.endX;
            document.getElementById('anim-end-y').value = animParams.endY;
            document.getElementById('anim-end-z').value = animParams.endZ;
            // ç›®æ ‡ç‚¹
            document.getElementById('anim-target-start-x').value = animParams.targetStartX;
            document.getElementById('anim-target-start-y').value = animParams.targetStartY;
            document.getElementById('anim-target-start-z').value = animParams.targetStartZ;
            document.getElementById('anim-target-end-x').value = animParams.targetEndX;
            document.getElementById('anim-target-end-y').value = animParams.targetEndY;
            document.getElementById('anim-target-end-z').value = animParams.targetEndZ;

            document.getElementById('anim-duration').value = animParams.duration;
            document.getElementById('anim-easing').value = animParams.easing;
        }

        // ä»é¢æ¿è¯»å–å‚æ•°
        function readParamsFromPanel() {
            animParams.startX = parseFloat(document.getElementById('anim-start-x').value);
            animParams.startY = parseFloat(document.getElementById('anim-start-y').value);
            animParams.startZ = parseFloat(document.getElementById('anim-start-z').value);
            animParams.endX = parseFloat(document.getElementById('anim-end-x').value);
            animParams.endY = parseFloat(document.getElementById('anim-end-y').value);
            animParams.endZ = parseFloat(document.getElementById('anim-end-z').value);
            // ç›®æ ‡ç‚¹
            animParams.targetStartX = parseFloat(document.getElementById('anim-target-start-x').value);
            animParams.targetStartY = parseFloat(document.getElementById('anim-target-start-y').value);
            animParams.targetStartZ = parseFloat(document.getElementById('anim-target-start-z').value);
            animParams.targetEndX = parseFloat(document.getElementById('anim-target-end-x').value);
            animParams.targetEndY = parseFloat(document.getElementById('anim-target-end-y').value);
            animParams.targetEndZ = parseFloat(document.getElementById('anim-target-end-z').value);

            animParams.duration = parseFloat(document.getElementById('anim-duration').value);
            animParams.easing = document.getElementById('anim-easing').value;
        }

        // è®¾ç½®èµ·ç‚¹ä¸ºå½“å‰ä½ç½®ï¼ˆæ‘„åƒå¤´+ç›®æ ‡ç‚¹ï¼‰
        function setStartToCurrent() {
            document.getElementById('anim-start-x').value = camera.position.x.toFixed(2);
            document.getElementById('anim-start-y').value = camera.position.y.toFixed(2);
            document.getElementById('anim-start-z').value = camera.position.z.toFixed(2);
            // åŒæ—¶è®¾ç½®ç›®æ ‡ç‚¹
            document.getElementById('anim-target-start-x').value = controls.target.x.toFixed(2);
            document.getElementById('anim-target-start-y').value = controls.target.y.toFixed(2);
            document.getElementById('anim-target-start-z').value = controls.target.z.toFixed(2);
        }

        // è®¾ç½®ç»ˆç‚¹ä¸ºå½“å‰ä½ç½®ï¼ˆæ‘„åƒå¤´+ç›®æ ‡ç‚¹ï¼‰
        function setEndToCurrent() {
            document.getElementById('anim-end-x').value = camera.position.x.toFixed(2);
            document.getElementById('anim-end-y').value = camera.position.y.toFixed(2);
            document.getElementById('anim-end-z').value = camera.position.z.toFixed(2);
            // åŒæ—¶è®¾ç½®ç›®æ ‡ç‚¹
            document.getElementById('anim-target-end-x').value = controls.target.x.toFixed(2);
            document.getElementById('anim-target-end-y').value = controls.target.y.toFixed(2);
            document.getElementById('anim-target-end-z').value = controls.target.z.toFixed(2);
        }

        // ============ å½•åˆ¶åŠŸèƒ½ ============
        let recordReady = false;   // å‡†å¤‡å½•åˆ¶
        let isRecording = false;   // æ­£åœ¨å½•åˆ¶
        let recordStartTime = 0;
        let recordedFrames = [];   // é€å¸§å½•åˆ¶çš„æ•°æ®
        let isPlayingRecording = false;  // æ­£åœ¨å›æ”¾å½•åˆ¶
        let playbackFrame = 0;     // å½“å‰å›æ”¾å¸§

        function prepareRecording() {
            if (recordReady || isRecording) {
                console.log('[R] å·²åœ¨å½•åˆ¶çŠ¶æ€ï¼Œå¿½ç•¥');
                return;
            }
            recordReady = true;
            console.log('[R] recordReady è®¾ä¸º true');

            // æ˜¾ç¤ºå‡†å¤‡çŠ¶æ€
            const debugEl = document.getElementById('debug-info');
            debugEl.style.display = 'block';
            debugEl.style.border = '2px solid #ff0';
            document.getElementById('record-status').innerHTML = 'â³ å‡†å¤‡å½•åˆ¶... æŒ‰ä½é¼ æ ‡æ‹–åŠ¨';

            console.log('â³ å‡†å¤‡å½•åˆ¶... æŒ‰ä½é¼ æ ‡æ‹–åŠ¨');
        }

        function startRecording() {
            if (!recordReady || isRecording) return;
            recordReady = false;
            isRecording = true;
            recordStartTime = performance.now();
            recordedFrames = [];  // æ¸…ç©ºå¸§æ•°ç»„

            // è®°å½•ç¬¬ä¸€å¸§
            recordedFrames.push({
                px: camera.position.x,
                py: camera.position.y,
                pz: camera.position.z,
                tx: controls.target.x,
                ty: controls.target.y,
                tz: controls.target.z
            });

            // æ˜¾ç¤ºå½•åˆ¶çŠ¶æ€
            document.getElementById('debug-info').style.border = '2px solid #f00';
            document.getElementById('record-status').innerHTML = 'ğŸ”´ å½•åˆ¶ä¸­... æ¾å¼€é¼ æ ‡ç»“æŸ';
            console.log('ğŸ”´ å¼€å§‹å½•åˆ¶...');
        }

        function stopRecording() {
            if (!isRecording) return;
            isRecording = false;

            // è®¡ç®—æ—¶é•¿å’Œå¸§æ•°
            const duration = ((performance.now() - recordStartTime) / 1000).toFixed(1);

            // æ¢å¤è°ƒè¯•é¢æ¿æ ·å¼
            document.getElementById('debug-info').style.border = 'none';
            document.getElementById('record-status').innerHTML = `âœ… å½•åˆ¶å®Œæˆ (${duration}ç§’, ${recordedFrames.length}å¸§)`;

            console.log(`â¹ å½•åˆ¶ç»“æŸï¼Œæ—¶é•¿: ${duration}ç§’, å¸§æ•°: ${recordedFrames.length}`);
        }

        // é€å¸§å½•åˆ¶ï¼ˆåœ¨ animate ä¸­è°ƒç”¨ï¼‰
        function recordFrame() {
            if (!isRecording) return;
            recordedFrames.push({
                px: camera.position.x,
                py: camera.position.y,
                pz: camera.position.z,
                tx: controls.target.x,
                ty: controls.target.y,
                tz: controls.target.z
            });
        }

        // æŒ‰ R é”®å‡†å¤‡å½•åˆ¶
        window.addEventListener('keydown', (e) => {
            if (e.key === 'r' || e.key === 'R') {
                if (!cameraAnimating && controls.enabled) {
                    prepareRecording();
                }
            }
        });

        // ã€å½•åˆ¶ã€‘ä½¿ç”¨ pointerdownï¼ˆæ¯” mousedown æ›´æ—©è§¦å‘ï¼Œä¸ä¼šè¢« OrbitControls é˜»æ­¢ï¼‰
        document.addEventListener('pointerdown', (e) => {
            console.log('[pointerdown] target:', e.target.tagName, e.target.id || e.target.className);
            console.log('[pointerdown] recordReady:', recordReady, 'isRecording:', isRecording);

            // å¦‚æœå‡†å¤‡å½•åˆ¶çŠ¶æ€ï¼Œä¸”ä¸æ˜¯ç‚¹å‡»è°ƒè¯•é¢æ¿ï¼Œå°±å¼€å§‹å½•åˆ¶
            const debugPanel = document.getElementById('debug-info');
            if (recordReady && !debugPanel.contains(e.target)) {
                console.log('[pointerdown] >>> å¼€å§‹å½•åˆ¶!');
                startRecording();
            }
        }, true);

        // ã€å½•åˆ¶ã€‘ä½¿ç”¨ pointerup ç»“æŸå½•åˆ¶
        document.addEventListener('pointerup', () => {
            console.log('[pointerup] isRecording:', isRecording);
            if (isRecording) {
                stopRecording();
            }
        }, true);

        // ============ æ–‡å­—é…ç½®åŠŸèƒ½ ============
        function applyTextConfig() {
            const overlay = document.querySelector('.text-overlay');

            // åº”ç”¨ä½ç½®
            overlay.style.left = document.getElementById('text-left').value;
            overlay.style.top = document.getElementById('text-top').value;

            // æ¸…ç©ºç°æœ‰å†…å®¹
            overlay.innerHTML = '';

            // åº”ç”¨æ¯è¡Œé…ç½®
            for (let i = 0; i < 2; i++) {
                const content = document.getElementById(`text-content-${i}`).value;
                if (!content) continue;

                const fontSize = document.getElementById(`text-size-${i}`).value;
                const color = document.getElementById(`text-color-${i}`).value;
                const italic = document.getElementById(`text-italic-${i}`).checked;
                const font = document.getElementById(`text-font-${i}`).value;

                const el = document.createElement(i === 0 ? 'h1' : 'p');
                el.textContent = content;
                el.style.fontSize = fontSize;
                el.style.color = color;
                el.style.fontStyle = italic ? 'italic' : 'normal';
                el.style.fontWeight = 'normal';
                el.style.margin = i === 0 ? '0 0 12px 0' : '0';
                el.style.textShadow = '0 0 30px rgba(255,255,255,0.4), 0 0 60px rgba(255,200,220,0.2)';
                el.style.animation = `float 4s ease-in-out infinite ${i * 0.5}s`;

                // å­—ä½“
                if (font === 'KaiTi') {
                    el.style.fontFamily = "'KaiTi', 'æ¥·ä½“', 'STKaiti', serif";
                } else if (font === 'sans-serif') {
                    el.style.fontFamily = "Arial, 'Helvetica Neue', sans-serif";
                } else {
                    el.style.fontFamily = "'Times New Roman', Georgia, serif";
                }

                overlay.appendChild(el);
            }
        }

        function printTextConfig() {
            const config = {
                left: document.getElementById('text-left').value,
                top: document.getElementById('text-top').value,
                lines: []
            };

            for (let i = 0; i < 2; i++) {
                config.lines.push({
                    content: document.getElementById(`text-content-${i}`).value,
                    fontSize: document.getElementById(`text-size-${i}`).value,
                    color: document.getElementById(`text-color-${i}`).value,
                    italic: document.getElementById(`text-italic-${i}`).checked,
                    font: document.getElementById(`text-font-${i}`).value
                });
            }

            console.log('=== æ–‡å­—é…ç½® ===');
            console.log(JSON.stringify(config, null, 2));
            console.log('================');
            alert(`ä½ç½®: left=${config.left}, top=${config.top}\n\nè¡Œ1: ${config.lines[0].content}\nè¡Œ2: ${config.lines[1].content}\n\nè¯¦ç»†é…ç½®å·²è¾“å‡ºåˆ°æ§åˆ¶å° (F12)`);
        }

        // é‡æ’­åŠ¨ç”»
        function replayAnimation() {
            readParamsFromPanel();

            console.log('=== é‡æ’­åŠ¨ç”» ===');
            console.log('æ‘„åƒå¤´èµ·ç‚¹:', animParams.startX, animParams.startY, animParams.startZ);
            console.log('æ‘„åƒå¤´ç»ˆç‚¹:', animParams.endX, animParams.endY, animParams.endZ);
            console.log('ç›®æ ‡ç‚¹èµ·ç‚¹:', animParams.targetStartX, animParams.targetStartY, animParams.targetStartZ);
            console.log('ç›®æ ‡ç‚¹ç»ˆç‚¹:', animParams.targetEndX, animParams.targetEndY, animParams.targetEndZ);
            console.log('æ—¶é•¿:', animParams.duration, 'ç¼“åŠ¨:', animParams.easing);

            // éšè—æ–‡å­—
            document.querySelector('.text-overlay').classList.add('hidden');
            controls.enabled = false;

            // å¦‚æœæœ‰å½•åˆ¶çš„å¸§æ•°æ®ï¼Œä½¿ç”¨é€å¸§å›æ”¾
            if (recordedFrames.length > 1) {
                console.log(`ä½¿ç”¨é€å¸§å›æ”¾ï¼Œå…± ${recordedFrames.length} å¸§`);
                isPlayingRecording = true;
                playbackFrame = 0;
                // è®¾ç½®åˆ°ç¬¬ä¸€å¸§
                const f = recordedFrames[0];
                camera.position.set(f.px, f.py, f.pz);
                controls.target.set(f.tx, f.ty, f.tz);
                controls.update();
            } else {
                // å¦åˆ™ä½¿ç”¨å‚æ•°æ’å€¼åŠ¨ç”»
                console.log('ä½¿ç”¨å‚æ•°æ’å€¼åŠ¨ç”»');
                camera.position.set(animParams.startX, animParams.startY, animParams.startZ);
                controls.target.set(animParams.targetStartX, animParams.targetStartY, animParams.targetStartZ);
                controls.update();
                cameraAnimating = true;
                cameraAnimProgress = 0;
            }
        }

        // è¾“å‡ºå‚æ•°åˆ°æ§åˆ¶å°
        function printParams() {
            readParamsFromPanel();
            console.log('=== åŠ¨ç”»å‚æ•° ===');
            console.log(`æ‘„åƒå¤´èµ·ç‚¹: (${animParams.startX}, ${animParams.startY}, ${animParams.startZ})`);
            console.log(`æ‘„åƒå¤´ç»ˆç‚¹: (${animParams.endX}, ${animParams.endY}, ${animParams.endZ})`);
            console.log(`ç›®æ ‡ç‚¹èµ·ç‚¹: (${animParams.targetStartX}, ${animParams.targetStartY}, ${animParams.targetStartZ})`);
            console.log(`ç›®æ ‡ç‚¹ç»ˆç‚¹: (${animParams.targetEndX}, ${animParams.targetEndY}, ${animParams.targetEndZ})`);
            console.log(`æ—¶é•¿: ${animParams.duration}ç§’`);
            console.log(`ç¼“åŠ¨: ${animParams.easing}`);
            console.log('================');
            alert(`å‚æ•°å·²è¾“å‡ºåˆ°æ§åˆ¶å° (F12)\n\næ‘„åƒå¤´èµ·ç‚¹: (${animParams.startX}, ${animParams.startY}, ${animParams.startZ})\næ‘„åƒå¤´ç»ˆç‚¹: (${animParams.endX}, ${animParams.endY}, ${animParams.endZ})\nç›®æ ‡ç‚¹èµ·ç‚¹: (${animParams.targetStartX}, ${animParams.targetStartY}, ${animParams.targetStartZ})\nç›®æ ‡ç‚¹ç»ˆç‚¹: (${animParams.targetEndX}, ${animParams.targetEndY}, ${animParams.targetEndZ})\næ—¶é•¿: ${animParams.duration}ç§’\nç¼“åŠ¨: ${animParams.easing}`);
        }

        // é¡µé¢åŠ è½½ååˆå§‹åŒ–é¢æ¿
        setTimeout(initDebugPanel, 100);

        // ç‚¹å‡»å¼€åœºè¦†ç›–å±‚
        document.getElementById('intro-overlay').addEventListener('click', () => {
            const overlay = document.getElementById('intro-overlay');
            overlay.style.transition = 'opacity 0.8s ease-out';
            overlay.style.opacity = '0';
            overlay.style.pointerEvents = 'none';  // ç«‹å³åœæ­¢æ‹¦æˆªé¼ æ ‡äº‹ä»¶

            setTimeout(() => {
                overlay.style.display = 'none';
            }, 800);

            // å¼€å§‹æ‘„åƒå¤´åŠ¨ç”»
            cameraAnimating = true;
            cameraAnimProgress = 0;
        });

        // ============ ç²’å­å‚æ•° ============
        const TREE_COUNT = 50000;
        const GROUND_COUNT = 40000;
        const STAR_COUNT = 2000;
        const ORNAMENT_COUNT = 120;      // æ ‘ä¸Šå½©è‰²è£…é¥°çƒ
        const FLOATING_SNOW_COUNT = 800; // æ¼‚æµ®çš„ç™½è‰²åœ†çƒï¼ˆæ— ç»†èŠ‚é›ªèŠ±ï¼‰
        const SNOWFLAKE_COUNT = 800;     // çœŸæ­£çš„å…­è§’é›ªèŠ±

        // ============ åˆ›å»ºå¤šç§é›ªèŠ±çº¹ç† (8ç§æ ·å¼) ============
        function createSnowflakeTextures() {
            const textures = [];

            // æ ·å¼1: ç»å…¸å…­è§’é›ªèŠ±ï¼ˆå¸¦åˆ†æ”¯ï¼‰
            function drawStyle1(ctx, cx, cy) {
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    ctx.lineTo(cx + Math.cos(angle) * 26, cy + Math.sin(angle) * 26);
                    ctx.stroke();
                    for (let d = 10; d <= 20; d += 10) {
                        for (let b = -1; b <= 1; b += 2) {
                            const bx = cx + Math.cos(angle) * d;
                            const by = cy + Math.sin(angle) * d;
                            const ba = angle + b * 0.6;
                            ctx.beginPath();
                            ctx.moveTo(bx, by);
                            ctx.lineTo(bx + Math.cos(ba) * 8 * (1 - d / 30), by + Math.sin(ba) * 8 * (1 - d / 30));
                            ctx.stroke();
                        }
                    }
                }
            }

            // æ ·å¼2: ç®€å•å…­è§’æ˜Ÿ
            function drawStyle2(ctx, cx, cy) {
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    ctx.lineTo(cx + Math.cos(angle) * 24, cy + Math.sin(angle) * 24);
                    ctx.stroke();
                }
            }

            // æ ·å¼3: å¯†é›†åˆ†æ”¯é›ªèŠ±
            function drawStyle3(ctx, cx, cy) {
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    ctx.lineTo(cx + Math.cos(angle) * 22, cy + Math.sin(angle) * 22);
                    ctx.stroke();
                    for (let d = 6; d <= 18; d += 6) {
                        for (let b = -1; b <= 1; b += 2) {
                            const bx = cx + Math.cos(angle) * d;
                            const by = cy + Math.sin(angle) * d;
                            const ba = angle + b * 0.5;
                            ctx.beginPath();
                            ctx.moveTo(bx, by);
                            ctx.lineTo(bx + Math.cos(ba) * 6, by + Math.sin(ba) * 6);
                            ctx.stroke();
                        }
                    }
                }
            }

            // æ ·å¼4: åœ†ç‚¹é›ªèŠ±
            function drawStyle4(ctx, cx, cy) {
                ctx.beginPath();
                ctx.arc(cx, cy, 4, 0, Math.PI * 2);
                ctx.fill();
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    const ex = cx + Math.cos(angle) * 20;
                    const ey = cy + Math.sin(angle) * 20;
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    ctx.lineTo(ex, ey);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(ex, ey, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // æ ·å¼5: æ˜Ÿå½¢é›ªèŠ±ï¼ˆ8è§’ï¼‰
            function drawStyle5(ctx, cx, cy) {
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const len = i % 2 === 0 ? 24 : 16;
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    ctx.lineTo(cx + Math.cos(angle) * len, cy + Math.sin(angle) * len);
                    ctx.stroke();
                }
            }

            // æ ·å¼6: èŠ±ç“£é›ªèŠ±
            function drawStyle6(ctx, cx, cy) {
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    // ä¸»å¹²
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    const ex = cx + Math.cos(angle) * 20;
                    const ey = cy + Math.sin(angle) * 20;
                    ctx.lineTo(ex, ey);
                    ctx.stroke();
                    // èŠ±ç“£å½¢çŠ¶ï¼ˆæ¤­åœ†å¼§ï¼‰
                    ctx.beginPath();
                    ctx.ellipse(
                        cx + Math.cos(angle) * 14,
                        cy + Math.sin(angle) * 14,
                        4, 8, angle, 0, Math.PI * 2
                    );
                    ctx.stroke();
                }
            }

            // æ ·å¼7: æ™¶æ ¼é›ªèŠ±
            function drawStyle7(ctx, cx, cy) {
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    ctx.lineTo(cx + Math.cos(angle) * 22, cy + Math.sin(angle) * 22);
                    ctx.stroke();
                    // æœ«ç«¯è±å½¢
                    const ex = cx + Math.cos(angle) * 18;
                    const ey = cy + Math.sin(angle) * 18;
                    const perpAngle = angle + Math.PI / 2;
                    ctx.beginPath();
                    ctx.moveTo(ex + Math.cos(angle) * 6, ey + Math.sin(angle) * 6);
                    ctx.lineTo(ex + Math.cos(perpAngle) * 4, ey + Math.sin(perpAngle) * 4);
                    ctx.lineTo(ex - Math.cos(angle) * 2, ey - Math.sin(angle) * 2);
                    ctx.lineTo(ex - Math.cos(perpAngle) * 4, ey - Math.sin(perpAngle) * 4);
                    ctx.closePath();
                    ctx.stroke();
                }
            }

            // æ ·å¼8: ç¾½æ¯›é›ªèŠ±ï¼ˆç»†å¯†åˆ†æ”¯ï¼‰
            function drawStyle8(ctx, cx, cy) {
                ctx.lineWidth = 1;
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    ctx.lineTo(cx + Math.cos(angle) * 24, cy + Math.sin(angle) * 24);
                    ctx.stroke();
                    // ç»†å¯†ç¾½æ¯›çŠ¶åˆ†æ”¯
                    for (let d = 4; d <= 22; d += 3) {
                        for (let b = -1; b <= 1; b += 2) {
                            const bx = cx + Math.cos(angle) * d;
                            const by = cy + Math.sin(angle) * d;
                            const ba = angle + b * 0.7;
                            const bLen = 4 * (1 - d / 28);
                            ctx.beginPath();
                            ctx.moveTo(bx, by);
                            ctx.lineTo(bx + Math.cos(ba) * bLen, by + Math.sin(ba) * bLen);
                            ctx.stroke();
                        }
                    }
                }
            }

            const styles = [drawStyle1, drawStyle2, drawStyle3, drawStyle4,
                drawStyle5, drawStyle6, drawStyle7, drawStyle8];

            for (let s = 0; s < styles.length; s++) {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.strokeStyle = 'white';
                ctx.fillStyle = 'white';
                ctx.lineWidth = 1.5;
                ctx.lineCap = 'round';
                styles[s](ctx, 32, 32);
                textures.push(new THREE.CanvasTexture(canvas));
            }

            return textures;
        }

        const snowflakeTextures = createSnowflakeTextures();

        // ============ é£å‘ç³»ç»Ÿ ============
        let windX = 0;      // å½“å‰é£å‘X
        let windZ = 0;      // å½“å‰é£å‘Z
        let targetWindX = 0; // ç›®æ ‡é£å‘X
        let targetWindZ = 0; // ç›®æ ‡é£å‘Z
        let lastMouseX = 0;
        let lastMouseZ = 0;
        let defaultWindPhase = 0; // é»˜è®¤é£å‘çš„ç›¸ä½

        // ç›‘å¬é¼ æ ‡æ‹–åŠ¨
        let isDragging = false;
        renderer.domElement.addEventListener('mousedown', () => { isDragging = true; });
        renderer.domElement.addEventListener('mouseup', () => { isDragging = false; });
        renderer.domElement.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.movementX * 0.01;
                const deltaY = e.movementY * 0.01;
                // é¼ æ ‡æ°´å¹³ç§»åŠ¨å½±å“é£å‘Xï¼Œå‚ç›´ç§»åŠ¨å½±å“é£å‘Z
                targetWindX += deltaX * 2;
                targetWindZ += deltaY * 0.5;
                // é™åˆ¶èŒƒå›´
                targetWindX = Math.max(-3, Math.min(3, targetWindX));
                targetWindZ = Math.max(-1, Math.min(1, targetWindZ));
            }
        });

        // ============ åˆ›å»ºæ ‘ç²’å­ ============
        function createTreeParticles() {
            const positions = new Float32Array(TREE_COUNT * 3);
            const colors = new Float32Array(TREE_COUNT * 3);
            const sizes = new Float32Array(TREE_COUNT);

            const colorStops = [
                { h: 0.0, color: new THREE.Color(1.0, 0.98, 0.95) },
                { h: 0.12, color: new THREE.Color(1.0, 0.95, 0.88) },
                { h: 0.25, color: new THREE.Color(1.0, 0.88, 0.80) },
                { h: 0.38, color: new THREE.Color(1.0, 0.78, 0.75) },
                { h: 0.50, color: new THREE.Color(1.0, 0.65, 0.68) },
                { h: 0.62, color: new THREE.Color(1.0, 0.52, 0.60) },
                { h: 0.75, color: new THREE.Color(0.98, 0.38, 0.52) },
                { h: 0.88, color: new THREE.Color(0.92, 0.25, 0.45) },
                { h: 1.0, color: new THREE.Color(0.85, 0.15, 0.38) },
            ];

            function getColorAtHeight(h) {
                for (let i = 0; i < colorStops.length - 1; i++) {
                    if (h >= colorStops[i].h && h <= colorStops[i + 1].h) {
                        const t = (h - colorStops[i].h) / (colorStops[i + 1].h - colorStops[i].h);
                        return colorStops[i].color.clone().lerp(colorStops[i + 1].color, t);
                    }
                }
                return colorStops[colorStops.length - 1].color;
            }

            for (let i = 0; i < TREE_COUNT; i++) {
                const i3 = i * 3;

                const h = Math.pow(Math.random(), 0.5);
                const y = h * 9 - 2.5;

                const maxRadius = 3.5 * (1 - h * 0.95);
                const r = Math.sqrt(Math.random()) * maxRadius;
                const theta = Math.random() * Math.PI * 2;

                positions[i3] = Math.cos(theta) * r;
                positions[i3 + 1] = y;
                positions[i3 + 2] = Math.sin(theta) * r;

                const color = getColorAtHeight(h);
                const brightness = 0.85 + Math.random() * 0.3;
                colors[i3] = Math.min(1, color.r * brightness);
                colors[i3 + 1] = Math.min(1, color.g * brightness);
                colors[i3 + 2] = Math.min(1, color.b * brightness);

                const sizeRand = Math.random();
                if (sizeRand > 0.98) {
                    sizes[i] = 0.12 + Math.random() * 0.08;
                    colors[i3] = colors[i3 + 1] = colors[i3 + 2] = 1.0;
                } else if (sizeRand > 0.9) {
                    sizes[i] = 0.07 + Math.random() * 0.05;
                } else if (sizeRand > 0.6) {
                    sizes[i] = 0.04 + Math.random() * 0.04;
                } else {
                    sizes[i] = 0.02 + Math.random() * 0.03;
                }
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    pixelRatio: { value: renderer.getPixelRatio() }
                },
                vertexShader: `
                    attribute float size;
                    varying vec3 vColor;
                    varying float vSize;
                    uniform float time;
                    uniform float pixelRatio;
                    
                    void main() {
                        vColor = color;
                        vSize = size;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        float twinkle = 0.88 + 0.12 * sin(time * 1.5 + position.x * 6.0 + position.y * 3.0);
                        gl_PointSize = size * pixelRatio * 320.0 / -mvPosition.z * twinkle;
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    varying float vSize;
                    void main() {
                        vec2 center = gl_PointCoord - 0.5;
                        float dist = length(center);
                        float softness = mix(1.8, 1.2, smoothstep(0.02, 0.15, vSize));
                        float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                        alpha = pow(alpha, softness);
                        vec3 finalColor = vColor + vec3(0.3) * max(0.0, 1.0 - dist * 2.5);
                        gl_FragColor = vec4(finalColor, alpha);
                    }
                `,
                transparent: true,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            return new THREE.Points(geometry, material);
        }

        // ============ åˆ›å»ºé“¶æ²³åœ°é¢ ============
        function createGroundParticles() {
            const positions = new Float32Array(GROUND_COUNT * 3);
            const colors = new Float32Array(GROUND_COUNT * 3);
            const sizes = new Float32Array(GROUND_COUNT);

            for (let i = 0; i < GROUND_COUNT; i++) {
                const i3 = i * 3;

                const rMax = 16;
                const r = Math.sqrt(Math.random()) * rMax;
                const theta = Math.random() * Math.PI * 2;

                positions[i3] = Math.cos(theta) * r;
                positions[i3 + 1] = -2.5 + (Math.random() - 0.5) * 0.2;
                positions[i3 + 2] = Math.sin(theta) * r;

                const colorMix = r / rMax;
                if (colorMix < 0.2) {
                    colors[i3] = 1.0;
                    colors[i3 + 1] = 0.95;
                    colors[i3 + 2] = 0.90;
                } else if (colorMix < 0.5) {
                    const t = (colorMix - 0.2) / 0.3;
                    colors[i3] = 1.0 - t * 0.15;
                    colors[i3 + 1] = 0.95 - t * 0.1;
                    colors[i3 + 2] = 0.90 + t * 0.1;
                } else {
                    colors[i3] = 0.75;
                    colors[i3 + 1] = 0.85;
                    colors[i3 + 2] = 1.0;
                }

                const brightness = 0.7 + 0.4 * Math.pow(1 - colorMix, 1.5);
                colors[i3] *= brightness;
                colors[i3 + 1] *= brightness;
                colors[i3 + 2] *= brightness;

                const sizeRand = Math.random();
                if (sizeRand > 0.97) {
                    sizes[i] = 0.06 + Math.random() * 0.04;
                } else if (sizeRand > 0.8) {
                    sizes[i] = 0.03 + Math.random() * 0.03;
                } else {
                    sizes[i] = 0.015 + Math.random() * 0.02;
                }
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    pixelRatio: { value: renderer.getPixelRatio() }
                },
                vertexShader: `
                    attribute float size;
                    varying vec3 vColor;
                    uniform float time;
                    uniform float pixelRatio;
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        float twinkle = 0.92 + 0.08 * sin(time * 1.0 + position.x * 3.0 + position.z * 3.0);
                        gl_PointSize = size * pixelRatio * 250.0 / -mvPosition.z * twinkle;
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    void main() {
                        vec2 center = gl_PointCoord - 0.5;
                        float dist = length(center);
                        float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                        alpha = pow(alpha, 1.4);
                        gl_FragColor = vec4(vColor, alpha * 0.9);
                    }
                `,
                transparent: true,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            return new THREE.Points(geometry, material);
        }

        // ============ åˆ›å»ºèƒŒæ™¯æ˜Ÿç©º ============
        function createStars() {
            const positions = new Float32Array(STAR_COUNT * 3);
            const sizes = new Float32Array(STAR_COUNT);

            for (let i = 0; i < STAR_COUNT; i++) {
                const i3 = i * 3;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 60 + Math.random() * 100;

                positions[i3] = r * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = r * Math.cos(phi);
                positions[i3 + 2] = r * Math.sin(phi) * Math.sin(theta);

                sizes[i] = 0.1 + Math.random() * 0.25;
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    pixelRatio: { value: renderer.getPixelRatio() }
                },
                vertexShader: `
                    attribute float size;
                    uniform float time;
                    uniform float pixelRatio;
                    varying float vAlpha;
                    void main() {
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        vAlpha = 0.6 + 0.4 * sin(time * 0.3 + position.x * 0.3 + position.y * 0.3);
                        gl_PointSize = size * pixelRatio * 200.0 / -mvPosition.z;
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying float vAlpha;
                    void main() {
                        vec2 center = gl_PointCoord - 0.5;
                        float dist = length(center);
                        float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                        gl_FragColor = vec4(1.0, 1.0, 1.0, alpha * vAlpha * 0.5);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            return new THREE.Points(geometry, material);
        }

        // ============ åˆ›å»ºé¡¶éƒ¨æ˜Ÿæ˜Ÿ (å¸¦é—ªçƒ) ============
        function createTopStar() {
            const count = 600;
            const positions = new Float32Array(count * 3);
            const sizes = new Float32Array(count);
            const phases = new Float32Array(count);  // é—ªçƒç›¸ä½

            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = Math.pow(Math.random(), 0.5) * 0.7;

                positions[i3] = r * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = 6.8 + r * Math.cos(phi);
                positions[i3 + 2] = r * Math.sin(phi) * Math.sin(theta);

                sizes[i] = 0.06 + Math.random() * 0.12;
                phases[i] = Math.random() * Math.PI * 2;
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('phase', new THREE.BufferAttribute(phases, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    pixelRatio: { value: renderer.getPixelRatio() }
                },
                vertexShader: `
                    attribute float size;
                    attribute float phase;
                    uniform float time;
                    uniform float pixelRatio;
                    varying float vBrightness;
                    
                    // ä¼ªéšæœºå‡½æ•°
                    float rand(float n) {
                        return fract(sin(n * 12.9898) * 43758.5453);
                    }
                    
                    void main() {
                        // å¤šå±‚éšæœºé—ªçƒ
                        float t = time + phase * 100.0;
                        float r1 = rand(floor(t * 2.0 + phase * 11.0));
                        float r2 = rand(floor(t * 6.0 + phase * 17.0));
                        float r3 = rand(floor(t * 12.0 + phase * 31.0));
                        
                        // æŸ”å’Œå‘¼å¸ + éšæœºé—ªçƒ + çªå‘äº®å…‰
                        float breathe = sin(t * 1.5) * 0.5 + 0.5;
                        float burst = step(0.88, r3);  // 12%æ¦‚ç‡çªç„¶é—ªäº®
                        
                        float twinkle = 0.4 + 0.3 * r1 + 0.2 * breathe + 0.6 * burst;
                        vBrightness = clamp(twinkle, 0.3, 1.5);
                        
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * pixelRatio * 400.0 / -mvPosition.z * (0.7 + 0.3 * vBrightness);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying float vBrightness;
                    
                    void main() {
                        vec2 center = gl_PointCoord - 0.5;
                        float dist = length(center);
                        float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                        alpha = pow(alpha, 0.9);
                        
                        // é‡‘ç™½è‰²æ¸å˜
                        vec3 color = vec3(1.0, 0.98, 0.92) * vBrightness;
                        gl_FragColor = vec4(color, alpha);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            return new THREE.Points(geometry, material);
        }

        // ============ åˆ›å»ºé—ªçƒç¯ä¸² (ä»£æ›¿è£…é¥°çƒ) ============
        const LIGHT_COUNT = 150;  // ç¯ä¸²æ•°é‡
        function createTwinklingLights() {
            const positions = new Float32Array(LIGHT_COUNT * 3);
            const colors = new Float32Array(LIGHT_COUNT * 3);
            const sizes = new Float32Array(LIGHT_COUNT);
            const phases = new Float32Array(LIGHT_COUNT);  // é—ªçƒç›¸ä½

            // æ¸©æš–æµªæ¼«çš„ç¯å…‰è‰²
            const lightColors = [
                new THREE.Color(1.0, 0.95, 0.8),   // æš–ç™½
                new THREE.Color(1.0, 0.85, 0.5),   // é‡‘é»„
                new THREE.Color(1.0, 0.7, 0.7),    // æ·¡ç²‰
                new THREE.Color(0.9, 0.95, 1.0),   // å†°è“
                new THREE.Color(1.0, 0.6, 0.4),    // æ©™çº¢
            ];

            for (let i = 0; i < LIGHT_COUNT; i++) {
                const i3 = i * 3;

                const h = Math.pow(Math.random(), 0.6);
                const y = h * 8.5 - 2;
                const maxR = 3.2 * (1 - h * 0.9);
                const r = (0.5 + Math.random() * 0.5) * maxR;
                const theta = Math.random() * Math.PI * 2;

                positions[i3] = Math.cos(theta) * r;
                positions[i3 + 1] = y;
                positions[i3 + 2] = Math.sin(theta) * r;

                const color = lightColors[Math.floor(Math.random() * lightColors.length)];
                colors[i3] = color.r;
                colors[i3 + 1] = color.g;
                colors[i3 + 2] = color.b;

                sizes[i] = 0.08 + Math.random() * 0.12;
                phases[i] = Math.random() * Math.PI * 2;
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('phase', new THREE.BufferAttribute(phases, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    pixelRatio: { value: renderer.getPixelRatio() }
                },
                vertexShader: `
                    attribute float size;
                    attribute float phase;
                    varying vec3 vColor;
                    varying float vBrightness;
                    uniform float time;
                    uniform float pixelRatio;
                    
                    // ä¼ªéšæœºå‡½æ•°
                    float rand(float n) {
                        return fract(sin(n * 12.9898) * 43758.5453);
                    }
                    
                    void main() {
                        vColor = color;
                        
                        // å¤šå±‚ä¸è§„åˆ™é—ªçƒ
                        float t = time + phase * 100.0;
                        float r1 = rand(floor(t * 1.5 + phase * 7.0));  // æ…¢é€Ÿéšæœºè·³å˜
                        float r2 = rand(floor(t * 4.0 + phase * 13.0)); // å¿«é€Ÿéšæœºè·³å˜
                        float r3 = rand(floor(t * 8.0 + phase * 23.0)); // è¶…å¿«é—ªçƒ
                        
                        // å¹³æ»‘è¿‡æ¸¡ + éšæœºçªå‘
                        float smooth1 = sin(t * (1.0 + phase * 2.0)) * 0.5 + 0.5;
                        float burst = step(0.85, r3);  // 15%æ¦‚ç‡çªç„¶é—ªäº®
                        
                        // ç»„åˆï¼šåŸºç¡€äº®åº¦ + éšæœºå˜åŒ– + çªå‘é—ªå…‰
                        float twinkle = 0.2 + 0.4 * r1 + 0.3 * smooth1 + 0.5 * burst;
                        twinkle = clamp(twinkle, 0.0, 1.5);  // å…è®¸è¶…è¿‡1.0
                        
                        vBrightness = twinkle;
                        
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        // æ›´å¤§çš„å›ºå®šå°ºå¯¸
                        gl_PointSize = size * pixelRatio * 40.0 * (0.6 + 0.4 * twinkle);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    varying float vBrightness;
                    
                    void main() {
                        vec2 center = gl_PointCoord - 0.5;
                        float dist = length(center);
                        
                        // æ›´å¼ºçš„å…‰æ™•
                        float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                        alpha = pow(alpha, 0.8);  // æ›´æŸ”å’Œæ›´å¤§çš„å…‰æ™•
                        
                        // ä¸­å¿ƒæ›´äº®ï¼Œæ•´ä½“æ›´äº®
                        vec3 finalColor = vColor * (1.5 + 1.0 * (1.0 - dist * 2.0));
                        
                        gl_FragColor = vec4(finalColor, alpha * vBrightness);
                    }
                `,
                transparent: true,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                depthTest: false  // ä¸è¢«å…¶ä»–å…ƒç´ é®æŒ¡
            });

            return new THREE.Points(geometry, material);
        }

        // ============ åˆ›å»ºæ¼‚æµ®çš„ç™½è‰²åœ†çƒ (æ— ç»†èŠ‚é›ªèŠ±) ============
        function createFloatingSnow() {
            const positions = new Float32Array(FLOATING_SNOW_COUNT * 3);
            const sizes = new Float32Array(FLOATING_SNOW_COUNT);
            const velocities = [];

            for (let i = 0; i < FLOATING_SNOW_COUNT; i++) {
                const i3 = i * 3;
                // æ‘„åƒå¤´æœ¬åœ°åæ ‡: è´ŸZæ˜¯å‰æ–¹
                positions[i3] = (Math.random() - 0.5) * 30;
                positions[i3 + 1] = Math.random() * 20 - 8;
                positions[i3 + 2] = -5 - Math.random() * 25; // è´ŸZæ˜¯å‰æ–¹

                sizes[i] = 0.08 + Math.random() * 0.15;
                velocities.push({
                    y: 0.2 + Math.random() * 0.4,
                    swayX: Math.random() * 0.5,
                    swayZ: Math.random() * 0.5,
                    phase: Math.random() * Math.PI * 2
                });
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    pixelRatio: { value: renderer.getPixelRatio() }
                },
                vertexShader: `
                    attribute float size;
                    uniform float pixelRatio;
                    varying float vAlpha;
                    
                    void main() {
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        vAlpha = 0.7;
                        gl_PointSize = size * pixelRatio * 150.0 / -mvPosition.z;
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying float vAlpha;
                    void main() {
                        vec2 center = gl_PointCoord - 0.5;
                        float dist = length(center);
                        // æŸ”å’Œçš„åœ†å½¢
                        float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                        alpha = pow(alpha, 1.5);
                        gl_FragColor = vec4(1.0, 1.0, 1.0, alpha * vAlpha);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            const points = new THREE.Points(geometry, material);
            points.userData.velocities = velocities;
            return points;
        }

        // ============ åˆ›å»ºå…­è§’é›ªèŠ± (å¤šæ ·å¼ï¼Œé è¿‘æ‘„åƒå¤´) ============
        function createSnowflakes() {
            const positions = new Float32Array(SNOWFLAKE_COUNT * 3);
            const sizes = new Float32Array(SNOWFLAKE_COUNT);
            const textureIndices = new Float32Array(SNOWFLAKE_COUNT);
            const velocities = [];

            for (let i = 0; i < SNOWFLAKE_COUNT; i++) {
                const i3 = i * 3;
                // æ‘„åƒå¤´æœ¬åœ°åæ ‡: è´ŸZæ˜¯å‰æ–¹
                positions[i3] = (Math.random() - 0.5) * 25;
                positions[i3 + 1] = Math.random() * 20 - 8;
                positions[i3 + 2] = -3 - Math.random() * 20;

                // æ›´å¤§çš„å°ºå¯¸å˜åŒ–èŒƒå›´
                sizes[i] = 0.3 + Math.random() * 0.8;
                // éšæœºåˆ†é…çº¹ç†ç´¢å¼• (0-7)
                textureIndices[i] = Math.floor(Math.random() * 8);
                velocities.push({
                    y: 0.6 + Math.random() * 0.6,  // åŸºç¡€ä¸‹è½é€Ÿåº¦
                    swayAmp: 0.15 + Math.random() * 0.35,  // æ‘†åŠ¨å¹…åº¦
                    phase: Math.random() * Math.PI * 2,
                    rotSpeed: (Math.random() - 0.5) * 2  // æ—‹è½¬é€Ÿåº¦
                });
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('texIndex', new THREE.BufferAttribute(textureIndices, 1));

            // ä½¿ç”¨çº¹ç†æ•°ç»„
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    textures: { value: snowflakeTextures },
                    pixelRatio: { value: renderer.getPixelRatio() }
                },
                vertexShader: `
                    attribute float size;
                    attribute float texIndex;
                    uniform float pixelRatio;
                    varying float vAlpha;
                    varying float vTexIndex;
                    
                    void main() {
                        vTexIndex = texIndex;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        vAlpha = 0.7;
                        gl_PointSize = size * pixelRatio * 120.0 / -mvPosition.z;
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform sampler2D textures[8];
                    varying float vAlpha;
                    varying float vTexIndex;
                    
                    void main() {
                        vec4 texColor;
                        int idx = int(vTexIndex);
                        if (idx == 0) texColor = texture2D(textures[0], gl_PointCoord);
                        else if (idx == 1) texColor = texture2D(textures[1], gl_PointCoord);
                        else if (idx == 2) texColor = texture2D(textures[2], gl_PointCoord);
                        else if (idx == 3) texColor = texture2D(textures[3], gl_PointCoord);
                        else if (idx == 4) texColor = texture2D(textures[4], gl_PointCoord);
                        else if (idx == 5) texColor = texture2D(textures[5], gl_PointCoord);
                        else if (idx == 6) texColor = texture2D(textures[6], gl_PointCoord);
                        else texColor = texture2D(textures[7], gl_PointCoord);
                        gl_FragColor = vec4(1.0, 1.0, 1.0, texColor.a * vAlpha);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            const points = new THREE.Points(geometry, material);
            points.userData.velocities = velocities;
            return points;
        }

        // ============ æ·»åŠ åˆ°åœºæ™¯ ============
        const treeParticles = createTreeParticles();
        const groundParticles = createGroundParticles();
        const stars = createStars();
        const topStar = createTopStar();
        const twinklingLights = createTwinklingLights();  // é—ªçƒç¯ä¸²
        const floatingSnow = createFloatingSnow();
        const snowflakes = createSnowflakes();

        scene.add(stars);
        scene.add(groundParticles);
        scene.add(treeParticles);
        scene.add(topStar);
        scene.add(twinklingLights);  // é—ªçƒç¯ä¸²

        // é›ªèŠ±æ·»åŠ åˆ°æ‘„åƒå¤´ä¸Šï¼Œä½¿å…¶å§‹ç»ˆåœ¨æ‘„åƒå¤´å‰æ–¹ï¼Œä¸å—è§†è§’æ—‹è½¬å½±å“
        camera.add(floatingSnow);
        camera.add(snowflakes);
        scene.add(camera); // éœ€è¦æŠŠæ‘„åƒå¤´æ·»åŠ åˆ°åœºæ™¯æ‰èƒ½æ¸²æŸ“å…¶å­å¯¹è±¡

        // ============ åŠ¨ç”» ============
        let time = 0;

        function animate() {
            requestAnimationFrame(animate);

            time += 0.016;

            // æ‘„åƒå¤´åŠ¨ç”»
            if (cameraAnimating) {
                cameraAnimProgress += 0.016 / animParams.duration;

                if (cameraAnimProgress >= 1) {
                    cameraAnimProgress = 1;
                    cameraAnimating = false;
                    controls.enabled = true;  // å¯ç”¨æ§ä»¶

                    console.log('[åŠ¨ç”»] å®Œæˆ! controls.enabled =', controls.enabled);

                    // æ˜¾ç¤ºæ–‡å­—
                    document.querySelector('.text-overlay').classList.remove('hidden');
                }

                const t = getEasing(cameraAnimProgress);

                // ç›®æ ‡ç‚¹åŠ¨ç”»ï¼ˆçº¿æ€§æ’å€¼å³å¯ï¼‰
                const targetX = animParams.targetStartX + (animParams.targetEndX - animParams.targetStartX) * t;
                const targetY = animParams.targetStartY + (animParams.targetEndY - animParams.targetStartY) * t;
                const targetZ = animParams.targetStartZ + (animParams.targetEndZ - animParams.targetStartZ) * t;
                controls.target.set(targetX, targetY, targetZ);

                // æ‘„åƒå¤´ä½ç½®åŠ¨ç”»ï¼šä½¿ç”¨çƒé¢æ’å€¼
                const startSpherical = cartesianToSpherical(
                    animParams.startX, animParams.startY, animParams.startZ,
                    animParams.targetStartX, animParams.targetStartY, animParams.targetStartZ
                );
                const endSpherical = cartesianToSpherical(
                    animParams.endX, animParams.endY, animParams.endZ,
                    animParams.targetEndX, animParams.targetEndY, animParams.targetEndZ
                );

                // åœ¨æåæ ‡ç©ºé—´æ’å€¼
                const r = startSpherical.r + (endSpherical.r - startSpherical.r) * t;
                const theta = startSpherical.theta + (endSpherical.theta - startSpherical.theta) * t;
                const phi = startSpherical.phi + (endSpherical.phi - startSpherical.phi) * t;

                // è½¬å›ç¬›å¡å°”åæ ‡
                const pos = sphericalToCartesian(r, theta, phi, targetX, targetY, targetZ);
                camera.position.set(pos.x, pos.y, pos.z);

                controls.update();
            }

            controls.update();

            // æ›´æ–°ç€è‰²å™¨ uniform
            treeParticles.material.uniforms.time.value = time;
            groundParticles.material.uniforms.time.value = time;
            stars.material.uniforms.time.value = time;
            topStar.material.uniforms.time.value = time;
            twinklingLights.material.uniforms.time.value = time;  // é—ªçƒç¯ä¸²

            // æ›´æ–°è°ƒè¯•ä¿¡æ¯
            const debugEl = document.getElementById('debug-info');
            if (debugEl.style.display !== 'none') {
                const pos = camera.position;
                const target = controls.target;
                const dx = pos.x - target.x;
                const dy = pos.y - target.y;
                const dz = pos.z - target.z;
                const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                const azimuth = Math.atan2(dx, dz) * 180 / Math.PI;
                const elevation = Math.asin(dy / dist) * 180 / Math.PI;
                document.getElementById('camera-info').innerHTML = `
                    <b>ğŸ“ æ‘„åƒå¤´ä½ç½®</b><br>
                    X: ${pos.x.toFixed(2)}<br>
                    Y: ${pos.y.toFixed(2)}<br>
                    Z: ${pos.z.toFixed(2)}<br>
                    <br>
                    <b>ğŸ¯ æåæ ‡</b><br>
                    è·ç¦»: ${dist.toFixed(2)}<br>
                    æ°´å¹³è§’: ${azimuth.toFixed(1)}Â°<br>
                    ä»°è§’: ${elevation.toFixed(1)}Â°
                `;
            }

            // æ›´æ–°æ¼‚æµ®é›ªçƒä½ç½®
            const floatPos = floatingSnow.geometry.attributes.position.array;
            const floatVel = floatingSnow.userData.velocities;
            for (let i = 0; i < FLOATING_SNOW_COUNT; i++) {
                const i3 = i * 3;
                const vel = floatVel[i];

                floatPos[i3 + 1] -= vel.y * 0.016;
                floatPos[i3] += Math.sin(time * 0.5 + vel.phase) * vel.swayX * 0.016;
                floatPos[i3 + 2] += Math.cos(time * 0.4 + vel.phase) * vel.swayZ * 0.016;

                // å¾ªç¯ (æ‘„åƒå¤´æœ¬åœ°åæ ‡)
                if (floatPos[i3 + 1] < -10) {
                    floatPos[i3 + 1] = 12;
                    floatPos[i3] = (Math.random() - 0.5) * 30;
                    floatPos[i3 + 2] = -5 - Math.random() * 25;
                }
            }
            floatingSnow.geometry.attributes.position.needsUpdate = true;

            // æ›´æ–°é£å‘ï¼ˆå¹³æ»‘è¿‡æ¸¡ï¼‰
            defaultWindPhase += 0.003;
            // é»˜è®¤é£å‘ç¼“æ…¢å˜åŒ–
            const defaultWindX = Math.sin(defaultWindPhase) * 0.8;
            const defaultWindZ = Math.cos(defaultWindPhase * 0.7) * 0.3;

            // ç›®æ ‡é£å‘æ…¢æ…¢å›å½’é»˜è®¤
            targetWindX = targetWindX * 0.98 + defaultWindX * 0.02;
            targetWindZ = targetWindZ * 0.98 + defaultWindZ * 0.02;

            // å½“å‰é£å‘å¹³æ»‘è¿½éšç›®æ ‡
            windX += (targetWindX - windX) * 0.05;
            windZ += (targetWindZ - windZ) * 0.05;

            // æ›´æ–°å…­è§’é›ªèŠ±ä½ç½®ï¼ˆå—é£å‘å½±å“ï¼‰
            const snowPos = snowflakes.geometry.attributes.position.array;
            const snowVel = snowflakes.userData.velocities;
            for (let i = 0; i < SNOWFLAKE_COUNT; i++) {
                const i3 = i * 3;
                const vel = snowVel[i];

                // ä¸‹è½ + é£å‘å½±å“ + å°å¹…æ‘†åŠ¨
                snowPos[i3 + 1] -= vel.y * 0.016;
                snowPos[i3] += (windX + Math.sin(time * 0.8 + vel.phase) * vel.swayAmp) * 0.016;
                snowPos[i3 + 2] += (windZ + Math.cos(time * 0.6 + vel.phase) * vel.swayAmp * 0.5) * 0.016;

                // å¾ªç¯ (æ‘„åƒå¤´æœ¬åœ°åæ ‡)
                if (snowPos[i3 + 1] < -10) {
                    snowPos[i3 + 1] = 12;
                    snowPos[i3] = (Math.random() - 0.5) * 25;
                    snowPos[i3 + 2] = -3 - Math.random() * 20;
                }
            }
            snowflakes.geometry.attributes.position.needsUpdate = true;

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // æŒ‰ ` é”®åˆ‡æ¢è°ƒè¯•é¢æ¿
        window.addEventListener('keydown', (e) => {
            if (e.key === '`') {
                const debugEl = document.getElementById('debug-info');
                debugEl.style.display = debugEl.style.display === 'none' ? 'block' : 'none';
            }
        });

        animate();
    </script>
</body>

</html>
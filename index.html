<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>âœ¨ Galaxy Christmas Tree âœ¨</title>

    <!-- é¢„åŠ è½½é‡‘å¸å›¾ç‰‡ -->
    <link rel="preload" href="png/g1.png" as="image">

    <script type="module">

        const container = document.getElementById('container');
        const scene = new THREE.Scene();


        const INITIAL_CONFIG_JSON = `{
  "animation": {
    "startX": -1.7,
    "startY": 14.4,
    "startZ": -2.2,
    "endX": -6.4,
    "endY": 4.4,
    "endZ": 10.7,
    "targetStartX": 0,
    "targetStartY": 6,
    "targetStartZ": 0,
    "targetEndX": 0,
    "targetEndY": 2,
    "targetEndZ": 0,
    "duration": 2.5,
    "easing": "easeOut",
    "recordedFrames": []
  },
  "text": {
    "left": "8%",
    "top": "38%",
    "lines": [
      {
        "content": "Merry Christmas",
        "fontSize": "clamp(32px, 5vw, 56px)",
        "color": "rgba(255,255,255,0.9)",
        "italic": true,
        "font": "serif"
      },
      {
        "content": "æˆ‘çˆ±ä½ ï¼Œå®è´",
        "fontSize": "clamp(20px, 3vw, 32px)",
        "color": "rgba(255,210,225,0.85)",
        "italic": false,
        "font": "KaiTi"
      }
    ]
  },
  "ornament": {
    "enabled": true,
    "type": "coin",
    "heartBeatSpeed": 1.5,
    "heartBeatScale": 0.15
  }
}`;

        // ============ å½•åˆ¶åŠŸèƒ½å˜é‡ (éœ€æå‰å£°æ˜) ============
        let recordReady = false;   // å‡†å¤‡å½•åˆ¶
        let isRecording = false;   // æ­£åœ¨å½•åˆ¶
        let recordStartTime = 0;
        let recordedFrames = [];   // é€å¸§å½•åˆ¶çš„æ•°æ®
        let isPlayingRecording = false;  // æ­£åœ¨å›æ”¾å½•åˆ¶
        let playbackFrame = 0;     // å½“å‰å›æ”¾å¸§

        // ============ é…ç½®ç®¡ç†ç³»ç»Ÿ ============
        const DEFAULT_CONFIG = JSON.parse(INITIAL_CONFIG_JSON);
        let appConfig = JSON.parse(INITIAL_CONFIG_JSON);


        const configManager = {
            // åŠ è½½é…ç½®ï¼šLocalStorage > Default
            load: function () {
                try {
                    const saved = localStorage.getItem('galaxy_tree_config');
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        // ç®€å•åˆå¹¶ï¼ˆå®é™…é¡¹ç›®ä¸­å¯èƒ½éœ€è¦æ·±åº¦åˆå¹¶ï¼‰
                        appConfig = { ...DEFAULT_CONFIG, ...parsed };

                        // æ·±åº¦åˆå¹¶ animation å’Œ textï¼Œé˜²æ­¢éƒ¨åˆ†ä¸¢å¤±
                        if (parsed.animation) {
                            appConfig.animation = { ...DEFAULT_CONFIG.animation, ...parsed.animation };
                            // æ¢å¤å½•åƒæ•°æ®
                            if (parsed.animation.recordedFrames && Array.isArray(parsed.animation.recordedFrames)) {
                                recordedFrames = parsed.animation.recordedFrames;
                                console.log(`âœ… æ¢å¤äº† ${recordedFrames.length} å¸§å½•åƒæ•°æ®`);
                            }
                        }
                        if (parsed.text) appConfig.text = { ...DEFAULT_CONFIG.text, ...parsed.text };
                        if (parsed.ornament) appConfig.ornament = { ...DEFAULT_CONFIG.ornament, ...parsed.ornament };

                        console.log('âœ… é…ç½®å·²ä» LocalStorage åŠ è½½');
                    } else {
                        console.log('â„¹ï¸ æœªæ‰¾åˆ°æœ¬åœ°é…ç½®ï¼Œä½¿ç”¨é»˜è®¤å€¼');
                    }
                } catch (e) {
                    console.error('é…ç½®åŠ è½½å¤±è´¥ï¼Œå·²è‡ªåŠ¨æ¢å¤é»˜è®¤', e);
                    // é™é»˜æ¢å¤é»˜è®¤å€¼ï¼Œä¸å¼¹çª—
                    appConfig = JSON.parse(JSON.stringify(DEFAULT_CONFIG));
                    recordedFrames = [];
                }
            },

            // å¯¼å‡º JSON
            export: function () {
                updateAppConfigFromInputs(); // ç¡®ä¿å¯¼å‡ºçš„æ˜¯å½“å‰é¢æ¿ä¸Šçš„å€¼
                // ç¡®ä¿å½•åƒæ•°æ®ä¹Ÿåœ¨å…¶ä¸­
                appConfig.animation.recordedFrames = recordedFrames;

                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(appConfig, null, 2));
                const downloadAnchorNode = document.createElement('a');
                downloadAnchorNode.setAttribute("href", dataStr);
                downloadAnchorNode.setAttribute("download", "galaxy_tree_config.json");
                document.body.appendChild(downloadAnchorNode);
                downloadAnchorNode.click();
                downloadAnchorNode.remove();
            },

            // å¯¼å…¥ JSON
            import: function (inputElement) {
                const file = inputElement.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function (e) {
                    try {
                        const parsed = JSON.parse(e.target.result);
                        // åŸºæœ¬æ ¡éªŒ
                        if (!parsed.animation || !parsed.text) {
                            throw new Error('JSON æ ¼å¼ä¸æ­£ç¡®');
                        }
                        appConfig = parsed;

                        // æ¢å¤å†…å­˜ä¸­çš„å½•åƒæ•°æ®
                        if (appConfig.animation.recordedFrames) {
                            recordedFrames = appConfig.animation.recordedFrames;
                        } else {
                            recordedFrames = [];
                        }

                        localStorage.setItem('galaxy_tree_config', JSON.stringify(appConfig));

                        // åˆ·æ–° UI
                        initDebugPanel();
                        applyTextConfig();

                        // é‡æ–°åˆå§‹åŒ–è£…é¥°ç‰©
                        if (typeof window.initSpiralOrnaments === 'function') {
                            window.initSpiralOrnaments();
                        }

                        alert('âœ… é…ç½®å¯¼å…¥æˆåŠŸï¼');
                    } catch (err) {
                        alert('âŒ å¯¼å…¥å¤±è´¥: ' + err.message);
                    }
                };
                reader.readAsText(file);
                // æ¸…é‡ inputï¼Œå…è®¸é‡å¤å¯¼å…¥åŒä¸€æ–‡ä»¶
                inputElement.value = '';
            },

            // é‡ç½®
            reset: function () {
                if (confirm('ç¡®å®šè¦é‡ç½®æ‰€æœ‰å‚æ•°å¹¶æ¸…é™¤æœ¬åœ°ç¼“å­˜å—ï¼Ÿ')) {
                    localStorage.removeItem('galaxy_tree_config');
                    appConfig = JSON.parse(JSON.stringify(DEFAULT_CONFIG));
                    recordedFrames = []; // æ¸…ç©ºå½•åƒ
                    initDebugPanel();
                    applyTextConfig();
                    alert('é…ç½®å·²é‡ç½® (å¦‚éœ€çœ‹æ•ˆæœå»ºè®®åˆ·æ–°é¡µé¢)');
                }
            }
        };

        // ç‹¬ç«‹ä¿å­˜åŠ¨ç”»é…ç½® (åŒ…å«å½•åƒæ•°æ®)
        function saveAnimationToLocal() {
            try {
                // 1. è¯»å–é¢æ¿æ•°å€¼åˆ° appConfig
                readParamsFromPanel();
                // 2. å°†å†…å­˜ä¸­çš„å½•åƒå¸§åŒæ­¥åˆ°é…ç½®
                appConfig.animation.recordedFrames = recordedFrames;

                // 3. è¯»å–ç°æœ‰ localStorageï¼Œä»…æ›´æ–° animation éƒ¨åˆ†
                const savedStr = localStorage.getItem('galaxy_tree_config');
                let savedConfig = savedStr ? JSON.parse(savedStr) : {};

                savedConfig.animation = appConfig.animation; // è¦†ç›–åŠ¨ç”»éƒ¨åˆ†

                localStorage.setItem('galaxy_tree_config', JSON.stringify(savedConfig));

                const msg = recordedFrames.length > 1
                    ? `âœ… åŠ¨ç”»å‚æ•°åŠ ${recordedFrames.length} å¸§å½•åƒå·²å†™å…¥ Local!`
                    : `âœ… åŠ¨ç”»å‚æ•°å·²å†™å…¥ Local (æ— å½•åƒæ•°æ®)`;
                alert(msg);
            } catch (e) {
                alert('âŒ ä¿å­˜å¤±è´¥: ' + e.message);
            }
        }

        // ç‹¬ç«‹ä¿å­˜æ–‡å­—é…ç½®
        function saveTextToLocal() {
            try {
                // 1. è¯»å–é¢æ¿æ•°å€¼åˆ° appConfig
                updateAppConfigFromInputs();

                // 2. è¯»å–ç°æœ‰ localStorageï¼Œä»…æ›´æ–° text éƒ¨åˆ†
                const savedStr = localStorage.getItem('galaxy_tree_config');
                let savedConfig = savedStr ? JSON.parse(savedStr) : {};

                savedConfig.text = appConfig.text; // è¦†ç›–æ–‡å­—éƒ¨åˆ†
                // ç¡®ä¿ savedConfig å…¶ä»–éƒ¨åˆ†ï¼ˆå¦‚ animationï¼‰å¦‚æœåŸæœ¬æ²¡æœ‰ï¼Œéœ€è¦è¡¥å…¨å—ï¼Ÿ
                if (!savedConfig.animation) {
                    savedConfig.animation = appConfig.animation;
                }

                localStorage.setItem('galaxy_tree_config', JSON.stringify(savedConfig));
                alert('âœ… æ–‡å­—é…ç½®å·²å†™å…¥ Local!');
            } catch (e) {
                alert('âŒ ä¿å­˜å¤±è´¥: ' + e.message);
            }
        }

        // åˆå§‹åŒ–åŠ è½½
        configManager.load();

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
        // åˆå§‹ä½ç½®: ä½¿ç”¨é…ç½®
        camera.position.set(appConfig.animation.startX, appConfig.animation.startY, appConfig.animation.startZ);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x000005, 1);
        container.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.rotateSpeed = 0.5;
        controls.enablePan = false;
        controls.minDistance = 5;
        controls.maxDistance = 50;
        controls.target.set(appConfig.animation.targetStartX, appConfig.animation.targetStartY, appConfig.animation.targetStartZ);  // åˆå§‹ç›®æ ‡ç‚¹
        controls.enabled = false;  // åŠ¨ç”»å®Œæˆå‰ç¦ç”¨
        controls.update();

        // ============ æ‘„åƒå¤´åŠ¨ç”»çŠ¶æ€ ============
        let cameraAnimating = false;
        let cameraAnimProgress = 0;

        // åŠ¨ç”»å‚æ•°ï¼ˆå¼•ç”¨ appConfig.animationï¼‰
        // ä¸ºäº†å…¼å®¹åŸæœ‰ä»£ç é€»è¾‘ï¼Œè¿™é‡Œå¯ä»¥åšä¸€ä¸ªä»£ç†ï¼Œæˆ–è€…ç›´æ¥ä¿®æ”¹ä¸‹æ–¹ä»£ç ä½¿ç”¨ appConfig.animation
        // ä¸‹é¢é€‰æ‹©ç›´æ¥æ›¿æ¢ä½¿ç”¨å¤„ï¼Œä½†ä¸ºäº†å‡å°‘æ”¹åŠ¨ï¼Œæˆ‘ä»¬è®© animParams æŒ‡å‘ appConfig.animation
        let animParams = appConfig.animation;

        // ç¼“åŠ¨å‡½æ•°é›†åˆ
        const easingFunctions = {
            linear: t => t,
            easeOut: t => 1 - Math.pow(1 - t, 3),
            easeIn: t => Math.pow(t, 3),
            easeInOut: t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2
        };

        // æåæ ‡è½¬æ¢ï¼šç¬›å¡å°” -> æåæ ‡ï¼ˆç›¸å¯¹äºç›®æ ‡ç‚¹ï¼‰
        function cartesianToSpherical(x, y, z, targetX, targetY, targetZ) {
            const dx = x - targetX;
            const dy = y - targetY;
            const dz = z - targetZ;
            const r = Math.sqrt(dx * dx + dy * dy + dz * dz);
            const theta = Math.atan2(dx, dz);  // æ–¹ä½è§’
            const phi = Math.acos(dy / r);     // ä»°è§’ï¼ˆä»Yè½´å‘ä¸‹ï¼‰
            return { r, theta, phi };
        }

        // æåæ ‡è½¬æ¢ï¼šæåæ ‡ -> ç¬›å¡å°”ï¼ˆç›¸å¯¹äºç›®æ ‡ç‚¹ï¼‰
        function sphericalToCartesian(r, theta, phi, targetX, targetY, targetZ) {
            const x = targetX + r * Math.sin(phi) * Math.sin(theta);
            const y = targetY + r * Math.cos(phi);
            const z = targetZ + r * Math.sin(phi) * Math.cos(theta);
            return { x, y, z };
        }

        function getEasing(t) {
            return easingFunctions[animParams.easing](t);
        }

        // åˆå§‹åŒ–è°ƒè¯•é¢æ¿è¾“å…¥æ¡† (ä» appConfig å¡«å……)
        function initDebugPanel() {
            const anim = appConfig.animation;
            document.getElementById('anim-start-x').value = anim.startX;
            document.getElementById('anim-start-y').value = anim.startY;
            document.getElementById('anim-start-z').value = anim.startZ;
            document.getElementById('anim-end-x').value = anim.endX;
            document.getElementById('anim-end-y').value = anim.endY;
            document.getElementById('anim-end-z').value = anim.endZ;
            // ç›®æ ‡ç‚¹
            document.getElementById('anim-target-start-x').value = anim.targetStartX;
            document.getElementById('anim-target-start-y').value = anim.targetStartY;
            document.getElementById('anim-target-start-z').value = anim.targetStartZ;
            document.getElementById('anim-target-end-x').value = anim.targetEndX;
            document.getElementById('anim-target-end-y').value = anim.targetEndY;
            document.getElementById('anim-target-end-z').value = anim.targetEndZ;

            document.getElementById('anim-duration').value = anim.duration;
            document.getElementById('anim-easing').value = anim.easing;

            // åˆå§‹åŒ–æ–‡å­—é…ç½®é¢æ¿
            const txt = appConfig.text;
            document.getElementById('text-left').value = txt.left;
            document.getElementById('text-top').value = txt.top;

            for (let i = 0; i < 2; i++) {
                const line = txt.lines[i] || { content: '', fontSize: '20px', color: 'white', italic: false, font: 'serif' };
                document.getElementById(`text-content-${i}`).value = line.content;
                document.getElementById(`text-size-${i}`).value = line.fontSize;
                document.getElementById(`text-color-${i}`).value = line.color;
                document.getElementById(`text-italic-${i}`).checked = line.italic;
                document.getElementById(`text-font-${i}`).value = line.font;
            }

            // åˆå§‹åŒ–è£…é¥°ç‰©é…ç½®é¢æ¿
            const orn = appConfig.ornament || { enabled: true, type: 'coin', heartBeatSpeed: 1.5, heartBeatScale: 0.15 };
            const ornEnabledEl = document.getElementById('ornament-enabled');
            const ornTypeEl = document.getElementById('ornament-type');
            const heartOptionsEl = document.getElementById('heart-options');

            if (ornEnabledEl) ornEnabledEl.checked = orn.enabled !== false;
            if (ornTypeEl) ornTypeEl.value = orn.type || 'coin';
            if (document.getElementById('heart-beat-speed')) {
                document.getElementById('heart-beat-speed').value = orn.heartBeatSpeed || 1.5;
            }
            if (document.getElementById('heart-beat-scale')) {
                document.getElementById('heart-beat-scale').value = orn.heartBeatScale || 0.15;
            }
            // æ˜¾ç¤º/éšè—æ¡ƒå¿ƒé€‰é¡¹
            if (heartOptionsEl) {
                heartOptionsEl.style.display = (orn.type === 'heart') ? 'block' : 'none';
            }

            // ç«‹å³åº”ç”¨æ–‡å­—é…ç½®æ˜¾ç¤ºå‡ºæ¥
            applyTextConfig();
        }

        // ä»é¢æ¿è¯»å–å‚æ•°åˆ° appConfig.animation
        function readParamsFromPanel() {
            const anim = appConfig.animation;
            anim.startX = parseFloat(document.getElementById('anim-start-x').value);
            anim.startY = parseFloat(document.getElementById('anim-start-y').value);
            anim.startZ = parseFloat(document.getElementById('anim-start-z').value);
            anim.endX = parseFloat(document.getElementById('anim-end-x').value);
            anim.endY = parseFloat(document.getElementById('anim-end-y').value);
            anim.endZ = parseFloat(document.getElementById('anim-end-z').value);
            // ç›®æ ‡ç‚¹
            anim.targetStartX = parseFloat(document.getElementById('anim-target-start-x').value);
            anim.targetStartY = parseFloat(document.getElementById('anim-target-start-y').value);
            anim.targetStartZ = parseFloat(document.getElementById('anim-target-start-z').value);
            anim.targetEndX = parseFloat(document.getElementById('anim-target-end-x').value);
            anim.targetEndY = parseFloat(document.getElementById('anim-target-end-y').value);
            anim.targetEndZ = parseFloat(document.getElementById('anim-target-end-z').value);

            anim.duration = parseFloat(document.getElementById('anim-duration').value);
            anim.easing = document.getElementById('anim-easing').value;
        }

        // æŠŠè¾“å…¥æ¡†çš„æ‰€æœ‰å€¼ï¼ˆåŠ¨ç”»+æ–‡å­—ï¼‰åŒæ­¥åˆ° appConfigï¼Œç”¨äºä¿å­˜
        function updateAppConfigFromInputs() {
            readParamsFromPanel(); // æ›´æ–°åŠ¨ç”»éƒ¨åˆ†

            // æ›´æ–°æ–‡å­—éƒ¨åˆ†
            const txt = appConfig.text;
            txt.left = document.getElementById('text-left').value;
            txt.top = document.getElementById('text-top').value;

            txt.lines = [];
            for (let i = 0; i < 2; i++) {
                txt.lines.push({
                    content: document.getElementById(`text-content-${i}`).value,
                    fontSize: document.getElementById(`text-size-${i}`).value,
                    color: document.getElementById(`text-color-${i}`).value,
                    italic: document.getElementById(`text-italic-${i}`).checked,
                    font: document.getElementById(`text-font-${i}`).value
                });
            }
        }

        // è®¾ç½®èµ·ç‚¹ä¸ºå½“å‰ä½ç½®ï¼ˆæ‘„åƒå¤´+ç›®æ ‡ç‚¹ï¼‰
        function setStartToCurrent() {
            document.getElementById('anim-start-x').value = camera.position.x.toFixed(2);
            document.getElementById('anim-start-y').value = camera.position.y.toFixed(2);
            document.getElementById('anim-start-z').value = camera.position.z.toFixed(2);
            // åŒæ—¶è®¾ç½®ç›®æ ‡ç‚¹
            document.getElementById('anim-target-start-x').value = controls.target.x.toFixed(2);
            document.getElementById('anim-target-start-y').value = controls.target.y.toFixed(2);
            document.getElementById('anim-target-start-z').value = controls.target.z.toFixed(2);
        }

        // è®¾ç½®ç»ˆç‚¹ä¸ºå½“å‰ä½ç½®ï¼ˆæ‘„åƒå¤´+ç›®æ ‡ç‚¹ï¼‰
        function setEndToCurrent() {
            document.getElementById('anim-end-x').value = camera.position.x.toFixed(2);
            document.getElementById('anim-end-y').value = camera.position.y.toFixed(2);
            document.getElementById('anim-end-z').value = camera.position.z.toFixed(2);
            // åŒæ—¶è®¾ç½®ç›®æ ‡ç‚¹
            document.getElementById('anim-target-end-x').value = controls.target.x.toFixed(2);
            document.getElementById('anim-target-end-y').value = controls.target.y.toFixed(2);
            document.getElementById('anim-target-end-z').value = controls.target.z.toFixed(2);
        }

        // ============ å½•åˆ¶åŠŸèƒ½ ============
        // å˜é‡å®šä¹‰å·²ç§»è‡³é¡¶éƒ¨

        function updateRecIndicator(state, text) {
            const el = document.getElementById('rec-indicator');
            el.className = ''; // reset classes
            el.style.display = 'block';
            el.textContent = text;

            if (state === 'ready') el.classList.add('rec-ready');
            else if (state === 'recording') el.classList.add('rec-recording');
            else if (state === 'saved') el.classList.add('rec-saved');
            else el.style.display = 'none';
        }

        function prepareRecording() {
            if (isRecording) return;
            // åˆ‡æ¢ Ready çŠ¶æ€
            recordReady = !recordReady;

            if (recordReady) {
                console.log('[R] è¿›å…¥å‡†å¤‡çŠ¶æ€');
                updateRecIndicator('ready', 'â— READY (Hold Click)');
            } else {
                console.log('[R] å–æ¶ˆå‡†å¤‡');
                updateRecIndicator('hide', '');
            }
        }

        function startRecording() {
            if (!recordReady || isRecording) return;
            // recordReady = false;
            isRecording = true;
            recordStartTime = performance.now();
            recordedFrames = [];  // æ¸…ç©ºå¸§æ•°ç»„

            // è®°å½•ç¬¬ä¸€å¸§
            recordedFrames.push({
                px: camera.position.x,
                py: camera.position.y,
                pz: camera.position.z,
                tx: controls.target.x,
                ty: controls.target.y,
                tz: controls.target.z
            });

            // æ˜¾ç¤ºå½•åˆ¶çŠ¶æ€
            const debugEl = document.getElementById('debug-info');
            if (debugEl.style.display !== 'none') {
                debugEl.style.border = '2px solid #f00';
                document.getElementById('record-status').innerHTML = 'ğŸ”´ å½•åˆ¶ä¸­... (æŒ‰Råœæ­¢)';
            }

            // æ˜¾ç¤º REC æŒ‡ç¤ºå™¨
            document.getElementById('rec-indicator').style.display = 'block';

            console.log('ğŸ”´ å¼€å§‹å½•åˆ¶...');
        }

        function stopRecording() {
            if (!isRecording) return;
            isRecording = false;
            recordReady = false; // å½•åˆ¶ç»“æŸï¼Œé€€å‡ºå‡†å¤‡çŠ¶æ€

            // è®¡ç®—æ—¶é•¿å’Œå¸§æ•°
            const duration = ((performance.now() - recordStartTime) / 1000).toFixed(1);

            // æ¢å¤è°ƒè¯•é¢æ¿æ ·å¼
            const debugEl = document.getElementById('debug-info');
            debugEl.style.border = 'none';
            document.getElementById('record-status').innerHTML = `âœ… å½•åˆ¶å®Œæˆ (${duration}ç§’, ${recordedFrames.length}å¸§)`;

            // éšè— REC æŒ‡ç¤ºå™¨
            document.getElementById('rec-indicator').style.display = 'none';

            console.log(`â¹ å½•åˆ¶ç»“æŸï¼Œæ—¶é•¿: ${duration}ç§’, å¸§æ•°: ${recordedFrames.length}`);
        }

        // é€å¸§å½•åˆ¶ï¼ˆåœ¨ animate ä¸­è°ƒç”¨ï¼‰
        function recordFrame() {
            if (!isRecording) return;
            recordedFrames.push({
                px: camera.position.x,
                py: camera.position.y,
                pz: camera.position.z,
                tx: controls.target.x,
                ty: controls.target.y,
                tz: controls.target.z
            });
        }

        // æŒ‰ R é”®åˆ‡æ¢å½•åˆ¶ï¼ŒæŒ‰ P é”®å›æ”¾
        window.addEventListener('keydown', (e) => {
            // R é”®: åˆ‡æ¢å‡†å¤‡å½•åˆ¶çŠ¶æ€
            if (e.key === 'r' || e.key === 'R') {
                if (!cameraAnimating && controls.enabled && !isRecording) {
                    prepareRecording();
                }
            }

            // P é”®: å›æ”¾ (ä»…å½“æœªå½•åˆ¶ä¸”æœªåŠ¨ç”»æ—¶)
            if (e.key === 'p' || e.key === 'P') {
                if (!isRecording && !cameraAnimating && recordedFrames.length > 0) {
                    replayAnimation();
                }
            }
        });

        // ã€å½•åˆ¶ã€‘ä½¿ç”¨ pointerdown å¼€å§‹ (éœ€è¦ R é”®å…ˆæ¿€æ´» Ready)
        document.addEventListener('pointerdown', (e) => {
            // å¦‚æœå‡†å¤‡å½•åˆ¶çŠ¶æ€ï¼Œä¸”ä¸æ˜¯ç‚¹å‡»è°ƒè¯•é¢æ¿
            const debugPanel = document.getElementById('debug-info');
            if (recordReady && !isRecording && !debugPanel.contains(e.target)) {
                startRecording();
            }
        }, true);

        // ã€å½•åˆ¶ã€‘ä½¿ç”¨ pointerup ç»“æŸå½•åˆ¶
        document.addEventListener('pointerup', () => {
            if (isRecording) {
                stopRecording();
            }
        }, true);

        // ============ æ–‡å­—é…ç½®åŠŸèƒ½ ============
        // ============ æ–‡å­—é…ç½®åŠŸèƒ½ ============
        function applyTextConfig() {
            // å…ˆåŒæ­¥åˆ° Configï¼Œç¡®ä¿ä¸€è‡´æ€§
            updateAppConfigFromInputs();
            const txt = appConfig.text;

            const overlay = document.querySelector('.text-overlay');

            // åº”ç”¨ä½ç½®
            overlay.style.left = txt.left;
            overlay.style.top = txt.top;

            // æ¸…ç©ºç°æœ‰å†…å®¹
            overlay.innerHTML = '';

            // åº”ç”¨æ¯è¡Œé…ç½®
            txt.lines.forEach((line, i) => {
                if (!line.content) return;

                const el = document.createElement(i === 0 ? 'h1' : 'p');
                el.textContent = line.content;
                el.style.fontSize = line.fontSize;
                el.style.color = line.color;
                el.style.fontStyle = line.italic ? 'italic' : 'normal';
                el.style.fontWeight = 'normal';
                el.style.margin = i === 0 ? '0 0 12px 0' : '0';
                el.style.textShadow = '0 0 30px rgba(255,255,255,0.4), 0 0 60px rgba(255,200,220,0.2)';
                el.style.animation = `float 4s ease-in-out infinite ${i * 0.5}s`;

                // å­—ä½“
                if (line.font === 'KaiTi') {
                    el.style.fontFamily = "'KaiTi', 'æ¥·ä½“', 'STKaiti', serif";
                } else if (line.font === 'sans-serif') {
                    el.style.fontFamily = "Arial, 'Helvetica Neue', sans-serif";
                } else {
                    el.style.fontFamily = "'Times New Roman', Georgia, serif";
                }

                overlay.appendChild(el);
            });
        }

        // è£…é¥°ç‰©é…ç½®å˜æ›´æ—¶çš„å›è°ƒï¼ˆæ˜¾ç¤º/éšè—æ¡ƒå¿ƒé€‰é¡¹ï¼‰
        function onOrnamentConfigChange() {
            const typeEl = document.getElementById('ornament-type');
            const heartOptionsEl = document.getElementById('heart-options');
            if (typeEl && heartOptionsEl) {
                heartOptionsEl.style.display = (typeEl.value === 'heart') ? 'block' : 'none';
            }
        }

        // åº”ç”¨è£…é¥°ç‰©é…ç½®
        function applyOrnamentConfig() {
            const enabled = document.getElementById('ornament-enabled')?.checked ?? true;
            const type = document.getElementById('ornament-type')?.value || 'coin';
            const heartBeatSpeed = parseFloat(document.getElementById('heart-beat-speed')?.value) || 1.5;
            const heartBeatScale = parseFloat(document.getElementById('heart-beat-scale')?.value) || 0.15;

            // æ›´æ–°é…ç½®
            appConfig.ornament = {
                enabled,
                type,
                heartBeatSpeed,
                heartBeatScale
            };

            // é‡æ–°åˆå§‹åŒ–è£…é¥°ç‰©
            if (typeof window.initSpiralOrnaments === 'function') {
                window.initSpiralOrnaments();
            } else {
                console.warn('âŒ initSpiralOrnaments å‡½æ•°æœªæ‰¾åˆ°');
            }

            console.log('âœ… è£…é¥°ç‰©é…ç½®å·²åº”ç”¨:', appConfig.ornament);
        }

        // ä¿å­˜è£…é¥°ç‰©é…ç½®åˆ°LocalStorage
        function saveOrnamentToLocal() {
            try {
                applyOrnamentConfig();

                const savedStr = localStorage.getItem('galaxy_tree_config');
                let savedConfig = savedStr ? JSON.parse(savedStr) : {};
                savedConfig.ornament = appConfig.ornament;
                localStorage.setItem('galaxy_tree_config', JSON.stringify(savedConfig));

                alert('âœ… è£…é¥°ç‰©é…ç½®å·²å†™å…¥ Local!');
            } catch (e) {
                alert('âŒ ä¿å­˜å¤±è´¥: ' + e.message);
            }
        }

        // æš´éœ²è£…é¥°ç‰©ç›¸å…³å‡½æ•°åˆ°å…¨å±€ï¼ˆä¾›HTML onclickè°ƒç”¨ï¼‰
        window.onOrnamentConfigChange = onOrnamentConfigChange;
        window.applyOrnamentConfig = applyOrnamentConfig;
        window.saveOrnamentToLocal = saveOrnamentToLocal;

        function printTextConfig() {
            updateAppConfigFromInputs();
            console.log('=== æ–‡å­—é…ç½® ===');
            console.log(JSON.stringify(appConfig.text, null, 2));
            console.log('================');
            alert(`é…ç½®å·²åŒæ­¥å¹¶è¾“å‡ºã€‚å»ºè®®ç›´æ¥ä½¿ç”¨é¢æ¿ä¸Šæ–¹çš„â€œå¯¼å‡ºJSONâ€åŠŸèƒ½ã€‚`);
        }

        // é‡æ’­åŠ¨ç”»
        function replayAnimation() {
            readParamsFromPanel();

            console.log('=== é‡æ’­åŠ¨ç”» ===');
            console.log('æ‘„åƒå¤´èµ·ç‚¹:', animParams.startX, animParams.startY, animParams.startZ);
            console.log('æ‘„åƒå¤´ç»ˆç‚¹:', animParams.endX, animParams.endY, animParams.endZ);
            console.log('ç›®æ ‡ç‚¹èµ·ç‚¹:', animParams.targetStartX, animParams.targetStartY, animParams.targetStartZ);
            console.log('ç›®æ ‡ç‚¹ç»ˆç‚¹:', animParams.targetEndX, animParams.targetEndY, animParams.targetEndZ);
            console.log('æ—¶é•¿:', animParams.duration, 'ç¼“åŠ¨:', animParams.easing);

            // éšè—æ–‡å­—
            document.querySelector('.text-overlay').classList.add('hidden');
            controls.enabled = false;

            // å¦‚æœæœ‰å½•åˆ¶çš„å¸§æ•°æ®ï¼Œä½¿ç”¨é€å¸§å›æ”¾
            if (recordedFrames.length > 1) {
                console.log(`ä½¿ç”¨é€å¸§å›æ”¾ï¼Œå…± ${recordedFrames.length} å¸§`);
                isPlayingRecording = true;
                playbackFrame = 0;
                // è®¾ç½®åˆ°ç¬¬ä¸€å¸§
                const f = recordedFrames[0];
                camera.position.set(f.px, f.py, f.pz);
                controls.target.set(f.tx, f.ty, f.tz);
                controls.update();
            } else {
                // å¦åˆ™ä½¿ç”¨å‚æ•°æ’å€¼åŠ¨ç”»
                console.log('ä½¿ç”¨å‚æ•°æ’å€¼åŠ¨ç”»');
                camera.position.set(animParams.startX, animParams.startY, animParams.startZ);
                controls.target.set(animParams.targetStartX, animParams.targetStartY, animParams.targetStartZ);
                controls.update();
                cameraAnimating = true;
                cameraAnimProgress = 0;
            }
        }

        // è¾“å‡ºå‚æ•°åˆ°æ§åˆ¶å°
        function printParams() {
            readParamsFromPanel();
            console.log('=== åŠ¨ç”»å‚æ•° ===');
            console.log(`æ‘„åƒå¤´èµ·ç‚¹: (${animParams.startX}, ${animParams.startY}, ${animParams.startZ})`);
            console.log(`æ‘„åƒå¤´ç»ˆç‚¹: (${animParams.endX}, ${animParams.endY}, ${animParams.endZ})`);
            console.log(`ç›®æ ‡ç‚¹èµ·ç‚¹: (${animParams.targetStartX}, ${animParams.targetStartY}, ${animParams.targetStartZ})`);
            console.log(`ç›®æ ‡ç‚¹ç»ˆç‚¹: (${animParams.targetEndX}, ${animParams.targetEndY}, ${animParams.targetEndZ})`);
            console.log(`æ—¶é•¿: ${animParams.duration}ç§’`);
            console.log(`ç¼“åŠ¨: ${animParams.easing}`);
            console.log('================');
            alert(`å‚æ•°å·²è¾“å‡ºåˆ°æ§åˆ¶å° (F12)ã€‚å»ºè®®ç›´æ¥ä½¿ç”¨é¢æ¿ä¸Šæ–¹çš„â€œå¯¼å‡ºJSONâ€åŠŸèƒ½ã€‚`);
        }

        // é¡µé¢åŠ è½½ååˆå§‹åŒ–é¢æ¿
        setTimeout(initDebugPanel, 100);

        // ç‚¹å‡»å¼€åœºè¦†ç›–å±‚
        document.getElementById('intro-overlay').addEventListener('click', () => {
            const overlay = document.getElementById('intro-overlay');
            overlay.style.transition = 'opacity 0.8s ease-out';
            overlay.style.opacity = '0';
            overlay.style.pointerEvents = 'none';  // ç«‹å³åœæ­¢æ‹¦æˆªé¼ æ ‡äº‹ä»¶

            setTimeout(() => {
                overlay.style.display = 'none';
            }, 800);

            // å¼€å§‹æ‘„åƒå¤´åŠ¨ç”»
            cameraAnimating = true;
            cameraAnimProgress = 0;
        });

        // ============ ç²’å­å‚æ•° ============
        const TREE_COUNT = 50000;
        const GROUND_COUNT = 40000;
        const STAR_COUNT = 2000;
        const ORNAMENT_COUNT = 120;      // æ ‘ä¸Šå½©è‰²è£…é¥°çƒ
        const FLOATING_SNOW_COUNT = 800; // æ¼‚æµ®çš„ç™½è‰²åœ†çƒï¼ˆæ— ç»†èŠ‚é›ªèŠ±ï¼‰
        const SNOWFLAKE_COUNT = 800;     // çœŸæ­£çš„å…­è§’é›ªèŠ±

        // ============ åˆ›å»ºå¤šç§é›ªèŠ±çº¹ç† (8ç§æ ·å¼) ============
        function createSnowflakeTextures() {
            const textures = [];

            // æ ·å¼1: ç»å…¸å…­è§’é›ªèŠ±ï¼ˆå¸¦åˆ†æ”¯ï¼‰
            function drawStyle1(ctx, cx, cy) {
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    ctx.lineTo(cx + Math.cos(angle) * 26, cy + Math.sin(angle) * 26);
                    ctx.stroke();
                    for (let d = 10; d <= 20; d += 10) {
                        for (let b = -1; b <= 1; b += 2) {
                            const bx = cx + Math.cos(angle) * d;
                            const by = cy + Math.sin(angle) * d;
                            const ba = angle + b * 0.6;
                            ctx.beginPath();
                            ctx.moveTo(bx, by);
                            ctx.lineTo(bx + Math.cos(ba) * 8 * (1 - d / 30), by + Math.sin(ba) * 8 * (1 - d / 30));
                            ctx.stroke();
                        }
                    }
                }
            }

            // æ ·å¼2: ç®€å•å…­è§’æ˜Ÿ
            function drawStyle2(ctx, cx, cy) {
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    ctx.lineTo(cx + Math.cos(angle) * 24, cy + Math.sin(angle) * 24);
                    ctx.stroke();
                }
            }

            // æ ·å¼3: å¯†é›†åˆ†æ”¯é›ªèŠ±
            function drawStyle3(ctx, cx, cy) {
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    ctx.lineTo(cx + Math.cos(angle) * 22, cy + Math.sin(angle) * 22);
                    ctx.stroke();
                    for (let d = 6; d <= 18; d += 6) {
                        for (let b = -1; b <= 1; b += 2) {
                            const bx = cx + Math.cos(angle) * d;
                            const by = cy + Math.sin(angle) * d;
                            const ba = angle + b * 0.5;
                            ctx.beginPath();
                            ctx.moveTo(bx, by);
                            ctx.lineTo(bx + Math.cos(ba) * 6, by + Math.sin(ba) * 6);
                            ctx.stroke();
                        }
                    }
                }
            }

            // æ ·å¼4: åœ†ç‚¹é›ªèŠ±
            function drawStyle4(ctx, cx, cy) {
                ctx.beginPath();
                ctx.arc(cx, cy, 4, 0, Math.PI * 2);
                ctx.fill();
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    const ex = cx + Math.cos(angle) * 20;
                    const ey = cy + Math.sin(angle) * 20;
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    ctx.lineTo(ex, ey);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(ex, ey, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // æ ·å¼5: æ˜Ÿå½¢é›ªèŠ±ï¼ˆ8è§’ï¼‰
            function drawStyle5(ctx, cx, cy) {
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const len = i % 2 === 0 ? 24 : 16;
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    ctx.lineTo(cx + Math.cos(angle) * len, cy + Math.sin(angle) * len);
                    ctx.stroke();
                }
            }

            // æ ·å¼6: èŠ±ç“£é›ªèŠ±
            function drawStyle6(ctx, cx, cy) {
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    // ä¸»å¹²
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    const ex = cx + Math.cos(angle) * 20;
                    const ey = cy + Math.sin(angle) * 20;
                    ctx.lineTo(ex, ey);
                    ctx.stroke();
                    // èŠ±ç“£å½¢çŠ¶ï¼ˆæ¤­åœ†å¼§ï¼‰
                    ctx.beginPath();
                    ctx.ellipse(
                        cx + Math.cos(angle) * 14,
                        cy + Math.sin(angle) * 14,
                        4, 8, angle, 0, Math.PI * 2
                    );
                    ctx.stroke();
                }
            }

            // æ ·å¼7: æ™¶æ ¼é›ªèŠ±
            function drawStyle7(ctx, cx, cy) {
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    ctx.lineTo(cx + Math.cos(angle) * 22, cy + Math.sin(angle) * 22);
                    ctx.stroke();
                    // æœ«ç«¯è±å½¢
                    const ex = cx + Math.cos(angle) * 18;
                    const ey = cy + Math.sin(angle) * 18;
                    const perpAngle = angle + Math.PI / 2;
                    ctx.beginPath();
                    ctx.moveTo(ex + Math.cos(angle) * 6, ey + Math.sin(angle) * 6);
                    ctx.lineTo(ex + Math.cos(perpAngle) * 4, ey + Math.sin(perpAngle) * 4);
                    ctx.lineTo(ex - Math.cos(angle) * 2, ey - Math.sin(angle) * 2);
                    ctx.lineTo(ex - Math.cos(perpAngle) * 4, ey - Math.sin(perpAngle) * 4);
                    ctx.closePath();
                    ctx.stroke();
                }
            }

            // æ ·å¼8: ç¾½æ¯›é›ªèŠ±ï¼ˆç»†å¯†åˆ†æ”¯ï¼‰
            function drawStyle8(ctx, cx, cy) {
                ctx.lineWidth = 1;
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    ctx.lineTo(cx + Math.cos(angle) * 24, cy + Math.sin(angle) * 24);
                    ctx.stroke();
                    // ç»†å¯†ç¾½æ¯›çŠ¶åˆ†æ”¯
                    for (let d = 4; d <= 22; d += 3) {
                        for (let b = -1; b <= 1; b += 2) {
                            const bx = cx + Math.cos(angle) * d;
                            const by = cy + Math.sin(angle) * d;
                            const ba = angle + b * 0.7;
                            const bLen = 4 * (1 - d / 28);
                            ctx.beginPath();
                            ctx.moveTo(bx, by);
                            ctx.lineTo(bx + Math.cos(ba) * bLen, by + Math.sin(ba) * bLen);
                            ctx.stroke();
                        }
                    }
                }
            }

            const styles = [drawStyle1, drawStyle2, drawStyle3, drawStyle4,
                drawStyle5, drawStyle6, drawStyle7, drawStyle8];

            for (let s = 0; s < styles.length; s++) {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.strokeStyle = 'white';
                ctx.fillStyle = 'white';
                ctx.lineWidth = 1.5;
                ctx.lineCap = 'round';
                styles[s](ctx, 32, 32);
                textures.push(new THREE.CanvasTexture(canvas));
            }

            return textures;
        }

        const snowflakeTextures = createSnowflakeTextures();

        // ============ é£å‘ç³»ç»Ÿ ============
        let windX = 0;      // å½“å‰é£å‘X
        let windZ = 0;      // å½“å‰é£å‘Z
        let targetWindX = 0; // ç›®æ ‡é£å‘X
        let targetWindZ = 0; // ç›®æ ‡é£å‘Z
        let lastMouseX = 0;
        let lastMouseZ = 0;
        let defaultWindPhase = 0; // é»˜è®¤é£å‘çš„ç›¸ä½

        // ç›‘å¬é¼ æ ‡æ‹–åŠ¨
        let isDragging = false;
        renderer.domElement.addEventListener('mousedown', () => { isDragging = true; });
        renderer.domElement.addEventListener('mouseup', () => { isDragging = false; });
        renderer.domElement.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.movementX * 0.01;
                const deltaY = e.movementY * 0.01;
                // é¼ æ ‡æ°´å¹³ç§»åŠ¨å½±å“é£å‘Xï¼Œå‚ç›´ç§»åŠ¨å½±å“é£å‘Z
                targetWindX += deltaX * 2;
                targetWindZ += deltaY * 0.5;
                // é™åˆ¶èŒƒå›´
                targetWindX = Math.max(-3, Math.min(3, targetWindX));
                targetWindZ = Math.max(-1, Math.min(1, targetWindZ));
            }
        });

        // ============ åˆ›å»ºæ ‘ç²’å­ ============
        function createTreeParticles() {
            const positions = new Float32Array(TREE_COUNT * 3);
            const colors = new Float32Array(TREE_COUNT * 3);
            const sizes = new Float32Array(TREE_COUNT);

            const colorStops = [
                { h: 0.0, color: new THREE.Color(1.0, 0.98, 0.95) },
                { h: 0.12, color: new THREE.Color(1.0, 0.95, 0.88) },
                { h: 0.25, color: new THREE.Color(1.0, 0.88, 0.80) },
                { h: 0.38, color: new THREE.Color(1.0, 0.78, 0.75) },
                { h: 0.50, color: new THREE.Color(1.0, 0.65, 0.68) },
                { h: 0.62, color: new THREE.Color(1.0, 0.52, 0.60) },
                { h: 0.75, color: new THREE.Color(0.98, 0.38, 0.52) },
                { h: 0.88, color: new THREE.Color(0.92, 0.25, 0.45) },
                { h: 1.0, color: new THREE.Color(0.85, 0.15, 0.38) },
            ];

            function getColorAtHeight(h) {
                for (let i = 0; i < colorStops.length - 1; i++) {
                    if (h >= colorStops[i].h && h <= colorStops[i + 1].h) {
                        const t = (h - colorStops[i].h) / (colorStops[i + 1].h - colorStops[i].h);
                        return colorStops[i].color.clone().lerp(colorStops[i + 1].color, t);
                    }
                }
                return colorStops[colorStops.length - 1].color;
            }

            for (let i = 0; i < TREE_COUNT; i++) {
                const i3 = i * 3;

                const h = Math.pow(Math.random(), 0.5);
                const y = h * 9 - 2.5;

                const maxRadius = 3.5 * (1 - h * 0.95);
                const r = Math.sqrt(Math.random()) * maxRadius;
                const theta = Math.random() * Math.PI * 2;

                positions[i3] = Math.cos(theta) * r;
                positions[i3 + 1] = y;
                positions[i3 + 2] = Math.sin(theta) * r;

                const color = getColorAtHeight(h);
                const brightness = 0.85 + Math.random() * 0.3;
                colors[i3] = Math.min(1, color.r * brightness);
                colors[i3 + 1] = Math.min(1, color.g * brightness);
                colors[i3 + 2] = Math.min(1, color.b * brightness);

                const sizeRand = Math.random();
                if (sizeRand > 0.98) {
                    sizes[i] = 0.12 + Math.random() * 0.08;
                    colors[i3] = colors[i3 + 1] = colors[i3 + 2] = 1.0;
                } else if (sizeRand > 0.9) {
                    sizes[i] = 0.07 + Math.random() * 0.05;
                } else if (sizeRand > 0.6) {
                    sizes[i] = 0.04 + Math.random() * 0.04;
                } else {
                    sizes[i] = 0.02 + Math.random() * 0.03;
                }
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    pixelRatio: { value: renderer.getPixelRatio() }
                },
                vertexShader: `
                    attribute float size;
                    varying vec3 vColor;
                    varying float vSize;
                    uniform float time;
                    uniform float pixelRatio;
                    
                    void main() {
                        vColor = color;
                        vSize = size;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        float twinkle = 0.88 + 0.12 * sin(time * 1.5 + position.x * 6.0 + position.y * 3.0);
                        gl_PointSize = size * pixelRatio * 320.0 / -mvPosition.z * twinkle;
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    varying float vSize;
                    void main() {
                        vec2 center = gl_PointCoord - 0.5;
                        float dist = length(center);
                        float softness = mix(1.8, 1.2, smoothstep(0.02, 0.15, vSize));
                        float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                        alpha = pow(alpha, softness);
                        vec3 finalColor = vColor + vec3(0.3) * max(0.0, 1.0 - dist * 2.5);
                        gl_FragColor = vec4(finalColor, alpha);
                    }
                `,
                transparent: true,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            return new THREE.Points(geometry, material);
        }

        // ============ åˆ›å»ºé“¶æ²³åœ°é¢ ============
        function createGroundParticles() {
            const positions = new Float32Array(GROUND_COUNT * 3);
            const colors = new Float32Array(GROUND_COUNT * 3);
            const sizes = new Float32Array(GROUND_COUNT);

            for (let i = 0; i < GROUND_COUNT; i++) {
                const i3 = i * 3;

                const rMax = 16;
                const r = Math.sqrt(Math.random()) * rMax;
                const theta = Math.random() * Math.PI * 2;

                positions[i3] = Math.cos(theta) * r;
                positions[i3 + 1] = -2.5 + (Math.random() - 0.5) * 0.2;
                positions[i3 + 2] = Math.sin(theta) * r;

                const colorMix = r / rMax;
                if (colorMix < 0.2) {
                    colors[i3] = 1.0;
                    colors[i3 + 1] = 0.95;
                    colors[i3 + 2] = 0.90;
                } else if (colorMix < 0.5) {
                    const t = (colorMix - 0.2) / 0.3;
                    colors[i3] = 1.0 - t * 0.15;
                    colors[i3 + 1] = 0.95 - t * 0.1;
                    colors[i3 + 2] = 0.90 + t * 0.1;
                } else {
                    colors[i3] = 0.75;
                    colors[i3 + 1] = 0.85;
                    colors[i3 + 2] = 1.0;
                }

                const brightness = 0.7 + 0.4 * Math.pow(1 - colorMix, 1.5);
                colors[i3] *= brightness;
                colors[i3 + 1] *= brightness;
                colors[i3 + 2] *= brightness;

                const sizeRand = Math.random();
                if (sizeRand > 0.97) {
                    sizes[i] = 0.06 + Math.random() * 0.04;
                } else if (sizeRand > 0.8) {
                    sizes[i] = 0.03 + Math.random() * 0.03;
                } else {
                    sizes[i] = 0.015 + Math.random() * 0.02;
                }
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    pixelRatio: { value: renderer.getPixelRatio() }
                },
                vertexShader: `
                    attribute float size;
                    varying vec3 vColor;
                    uniform float time;
                    uniform float pixelRatio;
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        float twinkle = 0.92 + 0.08 * sin(time * 1.0 + position.x * 3.0 + position.z * 3.0);
                        gl_PointSize = size * pixelRatio * 250.0 / -mvPosition.z * twinkle;
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    void main() {
                        vec2 center = gl_PointCoord - 0.5;
                        float dist = length(center);
                        float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                        alpha = pow(alpha, 1.4);
                        gl_FragColor = vec4(vColor, alpha * 0.9);
                    }
                `,
                transparent: true,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            return new THREE.Points(geometry, material);
        }

        // ============ åˆ›å»ºèƒŒæ™¯æ˜Ÿç©º ============
        function createStars() {
            const positions = new Float32Array(STAR_COUNT * 3);
            const sizes = new Float32Array(STAR_COUNT);

            for (let i = 0; i < STAR_COUNT; i++) {
                const i3 = i * 3;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 60 + Math.random() * 100;

                positions[i3] = r * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = r * Math.cos(phi);
                positions[i3 + 2] = r * Math.sin(phi) * Math.sin(theta);

                sizes[i] = 0.1 + Math.random() * 0.25;
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    pixelRatio: { value: renderer.getPixelRatio() }
                },
                vertexShader: `
                    attribute float size;
                    uniform float time;
                    uniform float pixelRatio;
                    varying float vAlpha;
                    void main() {
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        vAlpha = 0.6 + 0.4 * sin(time * 0.3 + position.x * 0.3 + position.y * 0.3);
                        gl_PointSize = size * pixelRatio * 200.0 / -mvPosition.z;
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying float vAlpha;
                    void main() {
                        vec2 center = gl_PointCoord - 0.5;
                        float dist = length(center);
                        float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                        gl_FragColor = vec4(1.0, 1.0, 1.0, alpha * vAlpha * 0.5);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            return new THREE.Points(geometry, material);
        }

        // ============ åˆ›å»ºé¡¶éƒ¨æ¢…å°”å¡å·´æ™¶ä½“ (Merkaba - ä¸¤ä¸ªç›¸äº¤çš„æ­£å››é¢ä½“) ============
        function createTopStar() {
            const count = 2000;  // ç²’å­æ•°é‡
            const positions = new Float32Array(count * 3);
            const sizes = new Float32Array(count);
            const phases = new Float32Array(count);  // é—ªçƒç›¸ä½

            const starCenterY = 8.0;  // æ™¶ä½“ä¸­å¿ƒé«˜åº¦ï¼ˆæé«˜é¿å…ä¸æ ‘é‡åˆï¼‰
            const scale = 1.2;        // æ™¶ä½“æ•´ä½“å¤§å°

            // æ­£å››é¢ä½“é¡¶ç‚¹ï¼ˆå‘ä¸Šçš„å››é¢ä½“ï¼‰
            const sqrt2 = Math.sqrt(2);
            const sqrt6 = Math.sqrt(6);
            const tetra1 = [
                { x: 0, y: 1, z: 0 },                          // é¡¶ç‚¹
                { x: sqrt2 * 2 / 3, y: -1 / 3, z: 0 },             // åº•é¢é¡¶ç‚¹1
                { x: -sqrt2 / 3, y: -1 / 3, z: sqrt6 / 3 },          // åº•é¢é¡¶ç‚¹2
                { x: -sqrt2 / 3, y: -1 / 3, z: -sqrt6 / 3 }          // åº•é¢é¡¶ç‚¹3
            ];

            // æ­£å››é¢ä½“é¡¶ç‚¹ï¼ˆå‘ä¸‹çš„å››é¢ä½“ï¼Œæ—‹è½¬60åº¦ï¼‰
            const tetra2 = [
                { x: 0, y: -1, z: 0 },                         // åº•ç‚¹
                { x: -sqrt2 * 2 / 3, y: 1 / 3, z: 0 },             // é¡¶é¢é¡¶ç‚¹1
                { x: sqrt2 / 3, y: 1 / 3, z: -sqrt6 / 3 },           // é¡¶é¢é¡¶ç‚¹2
                { x: sqrt2 / 3, y: 1 / 3, z: sqrt6 / 3 }             // é¡¶é¢é¡¶ç‚¹3
            ];

            // æ”¶é›†æ‰€æœ‰è¾¹ï¼ˆæ¯ä¸ªå››é¢ä½“6æ¡è¾¹ï¼Œå…±12æ¡è¾¹ï¼‰
            const edges = [];
            const addEdges = (verts) => {
                for (let i = 0; i < 4; i++) {
                    for (let j = i + 1; j < 4; j++) {
                        edges.push({ v1: verts[i], v2: verts[j] });
                    }
                }
            };
            addEdges(tetra1);
            addEdges(tetra2);

            // æ”¶é›†æ‰€æœ‰é¡¶ç‚¹ï¼ˆç”¨äºé¡¶ç‚¹å‘å…‰ï¼‰
            const vertices = [...tetra1, ...tetra2];

            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                const genType = Math.random();

                if (genType < 0.55) {
                    // 55%: æ²¿æ™¶ä½“è¾¹ç¼˜åˆ†å¸ƒ
                    const edge = edges[Math.floor(Math.random() * edges.length)];
                    const t = Math.random();  // æ²¿è¾¹çš„ä½ç½®

                    // è¾¹ç¼˜æœ‰è½»å¾®åšåº¦
                    const thickness = 0.03;
                    const offsetX = (Math.random() - 0.5) * thickness;
                    const offsetY = (Math.random() - 0.5) * thickness;
                    const offsetZ = (Math.random() - 0.5) * thickness;

                    const x = edge.v1.x + t * (edge.v2.x - edge.v1.x);
                    const y = edge.v1.y + t * (edge.v2.y - edge.v1.y);
                    const z = edge.v1.z + t * (edge.v2.z - edge.v1.z);

                    positions[i3] = x * scale + offsetX;
                    positions[i3 + 1] = starCenterY + y * scale + offsetY;
                    positions[i3 + 2] = z * scale + offsetZ;

                    sizes[i] = 0.06 + Math.random() * 0.06;
                } else if (genType < 0.75) {
                    // 20%: é¡¶ç‚¹å¤„é›†ä¸­å‘å…‰
                    const vertex = vertices[Math.floor(Math.random() * vertices.length)];
                    const spread = 0.08;

                    positions[i3] = vertex.x * scale + (Math.random() - 0.5) * spread;
                    positions[i3 + 1] = starCenterY + vertex.y * scale + (Math.random() - 0.5) * spread;
                    positions[i3 + 2] = vertex.z * scale + (Math.random() - 0.5) * spread;

                    // é¡¶ç‚¹ç²’å­æ›´å¤§æ›´äº®
                    sizes[i] = 0.1 + Math.random() * 0.12;
                } else if (genType < 0.9) {
                    // 15%: æ™¶ä½“æ ¸å¿ƒå‘å…‰
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const r = Math.pow(Math.random(), 0.5) * 0.3 * scale;

                    positions[i3] = r * Math.sin(phi) * Math.cos(theta);
                    positions[i3 + 1] = starCenterY + r * Math.cos(phi);
                    positions[i3 + 2] = r * Math.sin(phi) * Math.sin(theta);

                    sizes[i] = 0.08 + Math.random() * 0.1;
                } else {
                    // 10%: å¤–å›´å…‰æ™•ï¼ˆæŸ”å’Œçš„å…‰èŠ’ï¼‰
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const r = (1.0 + Math.random() * 0.5) * scale;

                    positions[i3] = r * Math.sin(phi) * Math.cos(theta);
                    positions[i3 + 1] = starCenterY + r * Math.cos(phi);
                    positions[i3 + 2] = r * Math.sin(phi) * Math.sin(theta);

                    sizes[i] = 0.04 + Math.random() * 0.04;
                }

                phases[i] = Math.random() * Math.PI * 2;
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('phase', new THREE.BufferAttribute(phases, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    pixelRatio: { value: renderer.getPixelRatio() }
                },
                vertexShader: `
                    attribute float size;
                    attribute float phase;
                    uniform float time;
                    uniform float pixelRatio;
                    varying float vBrightness;
                    
                    // ä¼ªéšæœºå‡½æ•°
                    float rand(float n) {
                        return fract(sin(n * 12.9898) * 43758.5453);
                    }
                    
                    void main() {
                        // å¤šå±‚éšæœºé—ªçƒ
                        float t = time + phase * 100.0;
                        float r1 = rand(floor(t * 2.0 + phase * 11.0));
                        float r2 = rand(floor(t * 6.0 + phase * 17.0));
                        float r3 = rand(floor(t * 12.0 + phase * 31.0));
                        
                        // æŸ”å’Œå‘¼å¸ + éšæœºé—ªçƒ + çªå‘äº®å…‰
                        float breathe = sin(t * 1.5) * 0.5 + 0.5;
                        float burst = step(0.88, r3);  // 12%æ¦‚ç‡çªç„¶é—ªäº®
                        
                        float twinkle = 0.4 + 0.3 * r1 + 0.2 * breathe + 0.6 * burst;
                        vBrightness = clamp(twinkle, 0.3, 1.5);
                        
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * pixelRatio * 400.0 / -mvPosition.z * (0.7 + 0.3 * vBrightness);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying float vBrightness;
                    
                    void main() {
                        vec2 center = gl_PointCoord - 0.5;
                        float dist = length(center);
                        float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                        alpha = pow(alpha, 0.9);
                        
                        // é‡‘ç™½è‰²æ¸å˜
                        vec3 color = vec3(1.0, 0.98, 0.92) * vBrightness;
                        gl_FragColor = vec4(color, alpha);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            return new THREE.Points(geometry, material);
        }

        // ============ åˆ›å»ºé—ªçƒç¯ä¸² (ä»£æ›¿è£…é¥°çƒ) ============
        const LIGHT_COUNT = 150;  // ç¯ä¸²æ•°é‡
        function createTwinklingLights() {
            const positions = new Float32Array(LIGHT_COUNT * 3);
            const colors = new Float32Array(LIGHT_COUNT * 3);
            const sizes = new Float32Array(LIGHT_COUNT);
            const phases = new Float32Array(LIGHT_COUNT);  // é—ªçƒç›¸ä½

            // æ¸©æš–æµªæ¼«çš„ç¯å…‰è‰²
            const lightColors = [
                new THREE.Color(1.0, 0.95, 0.8),   // æš–ç™½
                new THREE.Color(1.0, 0.85, 0.5),   // é‡‘é»„
                new THREE.Color(1.0, 0.7, 0.7),    // æ·¡ç²‰
                new THREE.Color(0.9, 0.95, 1.0),   // å†°è“
                new THREE.Color(1.0, 0.6, 0.4),    // æ©™çº¢
            ];

            for (let i = 0; i < LIGHT_COUNT; i++) {
                const i3 = i * 3;

                const h = Math.pow(Math.random(), 0.6);
                const y = h * 8.5 - 2;
                const maxR = 3.2 * (1 - h * 0.9);
                const r = (0.5 + Math.random() * 0.5) * maxR;
                const theta = Math.random() * Math.PI * 2;

                positions[i3] = Math.cos(theta) * r;
                positions[i3 + 1] = y;
                positions[i3 + 2] = Math.sin(theta) * r;

                const color = lightColors[Math.floor(Math.random() * lightColors.length)];
                colors[i3] = color.r;
                colors[i3 + 1] = color.g;
                colors[i3 + 2] = color.b;

                sizes[i] = 0.08 + Math.random() * 0.12;
                phases[i] = Math.random() * Math.PI * 2;
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('phase', new THREE.BufferAttribute(phases, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    pixelRatio: { value: renderer.getPixelRatio() }
                },
                vertexShader: `
                    attribute float size;
                    attribute float phase;
                    varying vec3 vColor;
                    varying float vBrightness;
                    uniform float time;
                    uniform float pixelRatio;
                    
                    // ä¼ªéšæœºå‡½æ•°
                    float rand(float n) {
                        return fract(sin(n * 12.9898) * 43758.5453);
                    }
                    
                    void main() {
                        vColor = color;
                        
                        // å¤šå±‚ä¸è§„åˆ™é—ªçƒ
                        float t = time + phase * 100.0;
                        float r1 = rand(floor(t * 1.5 + phase * 7.0));  // æ…¢é€Ÿéšæœºè·³å˜
                        float r2 = rand(floor(t * 4.0 + phase * 13.0)); // å¿«é€Ÿéšæœºè·³å˜
                        float r3 = rand(floor(t * 8.0 + phase * 23.0)); // è¶…å¿«é—ªçƒ
                        
                        // å¹³æ»‘è¿‡æ¸¡ + éšæœºçªå‘
                        float smooth1 = sin(t * (1.0 + phase * 2.0)) * 0.5 + 0.5;
                        float burst = step(0.85, r3);  // 15%æ¦‚ç‡çªç„¶é—ªäº®
                        
                        // ç»„åˆï¼šåŸºç¡€äº®åº¦ + éšæœºå˜åŒ– + çªå‘é—ªå…‰
                        float twinkle = 0.2 + 0.4 * r1 + 0.3 * smooth1 + 0.5 * burst;
                        twinkle = clamp(twinkle, 0.0, 1.5);  // å…è®¸è¶…è¿‡1.0
                        
                        vBrightness = twinkle;
                        
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        // æ›´å¤§çš„å›ºå®šå°ºå¯¸
                        gl_PointSize = size * pixelRatio * 40.0 * (0.6 + 0.4 * twinkle);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    varying float vBrightness;
                    
                    void main() {
                        vec2 center = gl_PointCoord - 0.5;
                        float dist = length(center);
                        
                        // æ›´å¼ºçš„å…‰æ™•
                        float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                        alpha = pow(alpha, 0.8);  // æ›´æŸ”å’Œæ›´å¤§çš„å…‰æ™•
                        
                        // ä¸­å¿ƒæ›´äº®ï¼Œæ•´ä½“æ›´äº®
                        vec3 finalColor = vColor * (1.5 + 1.0 * (1.0 - dist * 2.0));
                        
                        gl_FragColor = vec4(finalColor, alpha * vBrightness);
                    }
                `,
                transparent: true,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                depthTest: false  // ä¸è¢«å…¶ä»–å…ƒç´ é®æŒ¡
            });

            return new THREE.Points(geometry, material);
        }

        // ============ åˆ›å»ºæ¼‚æµ®çš„ç™½è‰²åœ†çƒ (æ— ç»†èŠ‚é›ªèŠ±) ============
        function createFloatingSnow() {
            const positions = new Float32Array(FLOATING_SNOW_COUNT * 3);
            const sizes = new Float32Array(FLOATING_SNOW_COUNT);
            const velocities = [];

            for (let i = 0; i < FLOATING_SNOW_COUNT; i++) {
                const i3 = i * 3;
                // æ‘„åƒå¤´æœ¬åœ°åæ ‡: è´ŸZæ˜¯å‰æ–¹
                positions[i3] = (Math.random() - 0.5) * 30;
                positions[i3 + 1] = Math.random() * 20 - 8;
                positions[i3 + 2] = -5 - Math.random() * 25; // è´ŸZæ˜¯å‰æ–¹

                sizes[i] = 0.08 + Math.random() * 0.15;
                velocities.push({
                    y: 0.2 + Math.random() * 0.4,
                    swayX: Math.random() * 0.5,
                    swayZ: Math.random() * 0.5,
                    phase: Math.random() * Math.PI * 2
                });
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    pixelRatio: { value: renderer.getPixelRatio() }
                },
                vertexShader: `
                    attribute float size;
                    uniform float pixelRatio;
                    varying float vAlpha;
                    
                    void main() {
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        vAlpha = 0.7;
                        gl_PointSize = size * pixelRatio * 150.0 / -mvPosition.z;
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying float vAlpha;
                    void main() {
                        vec2 center = gl_PointCoord - 0.5;
                        float dist = length(center);
                        // æŸ”å’Œçš„åœ†å½¢
                        float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                        alpha = pow(alpha, 1.5);
                        gl_FragColor = vec4(1.0, 1.0, 1.0, alpha * vAlpha);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            const points = new THREE.Points(geometry, material);
            points.userData.velocities = velocities;
            return points;
        }

        // ============ åˆ›å»ºå…­è§’é›ªèŠ± (å¤šæ ·å¼ï¼Œé è¿‘æ‘„åƒå¤´) ============
        function createSnowflakes() {
            const positions = new Float32Array(SNOWFLAKE_COUNT * 3);
            const sizes = new Float32Array(SNOWFLAKE_COUNT);
            const textureIndices = new Float32Array(SNOWFLAKE_COUNT);
            const velocities = [];

            for (let i = 0; i < SNOWFLAKE_COUNT; i++) {
                const i3 = i * 3;
                // æ‘„åƒå¤´æœ¬åœ°åæ ‡: è´ŸZæ˜¯å‰æ–¹
                positions[i3] = (Math.random() - 0.5) * 25;
                positions[i3 + 1] = Math.random() * 20 - 8;
                positions[i3 + 2] = -3 - Math.random() * 20;

                // æ›´å¤§çš„å°ºå¯¸å˜åŒ–èŒƒå›´
                sizes[i] = 0.3 + Math.random() * 0.8;
                // éšæœºåˆ†é…çº¹ç†ç´¢å¼• (0-7)
                textureIndices[i] = Math.floor(Math.random() * 8);
                velocities.push({
                    y: 0.6 + Math.random() * 0.6,  // åŸºç¡€ä¸‹è½é€Ÿåº¦
                    swayAmp: 0.15 + Math.random() * 0.35,  // æ‘†åŠ¨å¹…åº¦
                    phase: Math.random() * Math.PI * 2,
                    rotSpeed: (Math.random() - 0.5) * 2  // æ—‹è½¬é€Ÿåº¦
                });
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('texIndex', new THREE.BufferAttribute(textureIndices, 1));

            // ä½¿ç”¨çº¹ç†æ•°ç»„
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    textures: { value: snowflakeTextures },
                    pixelRatio: { value: renderer.getPixelRatio() }
                },
                vertexShader: `
                    attribute float size;
                    attribute float texIndex;
                    uniform float pixelRatio;
                    varying float vAlpha;
                    varying float vTexIndex;
                    
                    void main() {
                        vTexIndex = texIndex;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        vAlpha = 0.7;
                        gl_PointSize = size * pixelRatio * 120.0 / -mvPosition.z;
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform sampler2D textures[8];
                    varying float vAlpha;
                    varying float vTexIndex;
                    
                    void main() {
                        vec4 texColor;
                        int idx = int(vTexIndex);
                        if (idx == 0) texColor = texture2D(textures[0], gl_PointCoord);
                        else if (idx == 1) texColor = texture2D(textures[1], gl_PointCoord);
                        else if (idx == 2) texColor = texture2D(textures[2], gl_PointCoord);
                        else if (idx == 3) texColor = texture2D(textures[3], gl_PointCoord);
                        else if (idx == 4) texColor = texture2D(textures[4], gl_PointCoord);
                        else if (idx == 5) texColor = texture2D(textures[5], gl_PointCoord);
                        else if (idx == 6) texColor = texture2D(textures[6], gl_PointCoord);
                        else texColor = texture2D(textures[7], gl_PointCoord);
                        gl_FragColor = vec4(1.0, 1.0, 1.0, texColor.a * vAlpha);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            const points = new THREE.Points(geometry, material);
            points.userData.velocities = velocities;
            return points;
        }

        // ============ åˆ›å»ºé‡‘å¸çº¹ç† (è¥¿æ–¹é£æ ¼é‡‘å¸) ============
        function createGoldCoinTexture() {
            const size = 128;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            const cx = size / 2;
            const cy = size / 2;
            const radius = size / 2 - 6;

            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, size, size);

            // é‡‘å¸å¤–è¾¹ç¼˜ - æ·±é‡‘è‰²è¾¹æ¡†
            ctx.fillStyle = '#8B6914';
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
            ctx.fill();

            // é‡‘å¸ä¸»ä½“ - å®ä½“é‡‘è‰²æ¸å˜ï¼ˆæ¨¡æ‹Ÿ3Då‡¸èµ·æ•ˆæœï¼‰
            const coinGradient = ctx.createRadialGradient(
                cx - radius * 0.3, cy - radius * 0.3, 0,
                cx, cy, radius
            );
            coinGradient.addColorStop(0, '#FFF8DC');    // ä¸­å¿ƒé«˜äº®
            coinGradient.addColorStop(0.2, '#FFD700');  // äº®é‡‘è‰²
            coinGradient.addColorStop(0.5, '#DAA520');  // é‡‘è‰²
            coinGradient.addColorStop(0.8, '#B8860B');  // æš—é‡‘è‰²
            coinGradient.addColorStop(1, '#8B6914');    // è¾¹ç¼˜æ·±è‰²

            ctx.fillStyle = coinGradient;
            ctx.beginPath();
            ctx.arc(cx, cy, radius - 2, 0, Math.PI * 2);
            ctx.fill();

            // é”¯é½¿è¾¹ç¼˜æ•ˆæœï¼ˆé‡‘å¸è¾¹ç¼˜çš„å‡¹æ§½ï¼‰
            ctx.strokeStyle = '#8B6914';
            ctx.lineWidth = 2;
            const teethCount = 32;
            for (let i = 0; i < teethCount; i++) {
                const angle = (i / teethCount) * Math.PI * 2;
                const innerR = radius - 5;
                const outerR = radius - 2;
                ctx.beginPath();
                ctx.moveTo(cx + Math.cos(angle) * innerR, cy + Math.sin(angle) * innerR);
                ctx.lineTo(cx + Math.cos(angle) * outerR, cy + Math.sin(angle) * outerR);
                ctx.stroke();
            }

            // å†…åœˆè¾¹æ¡†
            ctx.strokeStyle = '#996515';
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            ctx.arc(cx, cy, radius * 0.72, 0, Math.PI * 2);
            ctx.stroke();

            // ä¸­å¿ƒçš‡å† å›¾æ¡ˆ
            ctx.fillStyle = '#8B6914';
            ctx.strokeStyle = '#8B6914';
            ctx.lineWidth = 2;

            // çš‡å† åº•åº§
            const crownW = radius * 0.5;
            const crownH = radius * 0.35;
            const crownY = cy - crownH * 0.3;

            ctx.beginPath();
            ctx.moveTo(cx - crownW / 2, crownY + crownH * 0.4);
            ctx.lineTo(cx + crownW / 2, crownY + crownH * 0.4);
            ctx.lineTo(cx + crownW * 0.4, crownY + crownH);
            ctx.lineTo(cx - crownW * 0.4, crownY + crownH);
            ctx.closePath();
            ctx.fill();

            // çš‡å† å°–è§’
            ctx.beginPath();
            ctx.moveTo(cx - crownW / 2, crownY + crownH * 0.4);
            ctx.lineTo(cx - crownW * 0.35, crownY - crownH * 0.2);
            ctx.lineTo(cx - crownW * 0.15, crownY + crownH * 0.2);
            ctx.lineTo(cx, crownY - crownH * 0.4);
            ctx.lineTo(cx + crownW * 0.15, crownY + crownH * 0.2);
            ctx.lineTo(cx + crownW * 0.35, crownY - crownH * 0.2);
            ctx.lineTo(cx + crownW / 2, crownY + crownH * 0.4);
            ctx.fill();

            // çš‡å† é¡¶éƒ¨å°åœ†ç 
            ctx.fillStyle = '#DAA520';
            const pearlPositions = [
                { x: cx - crownW * 0.35, y: crownY - crownH * 0.25 },
                { x: cx, y: crownY - crownH * 0.45 },
                { x: cx + crownW * 0.35, y: crownY - crownH * 0.25 }
            ];
            pearlPositions.forEach(pos => {
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 3, 0, Math.PI * 2);
                ctx.fill();
            });

            // é«˜å…‰æ•ˆæœï¼ˆå·¦ä¸Šè§’ï¼‰
            const highlightGradient = ctx.createRadialGradient(
                cx - radius * 0.35, cy - radius * 0.35, 0,
                cx - radius * 0.35, cy - radius * 0.35, radius * 0.55
            );
            highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.45)');
            highlightGradient.addColorStop(0.4, 'rgba(255, 255, 255, 0.15)');
            highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = highlightGradient;
            ctx.beginPath();
            ctx.arc(cx, cy, radius - 2, 0, Math.PI * 2);
            ctx.fill();

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        // ============ åˆ›å»ºæ¡ƒå¿ƒçº¹ç† ============
        function createHeartTexture() {
            const size = 128;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            const cx = size / 2;
            const cy = size / 2;
            const heartSize = size * 0.5;

            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, size, size);

            // ============ 1. ç»˜åˆ¶åŸºç¡€å½¢çŠ¶ (æ›´ç˜¦é•¿ã€é¥±æ»¡çš„å¿ƒå½¢) ============
            ctx.beginPath();
            // è°ƒæ•´å…³é”®ç‚¹ä½ç½®ï¼šæ›´çª„çš„å®½åº¦ï¼Œæ›´é•¿çš„å°¾å·´
            const topY = cy - heartSize * 0.4;
            const bottomTipY = cy + heartSize * 0.95; // æ›´é•¿çš„å°¾å·´
            const widthFactor = 1.15; // å®½åº¦ç³»æ•°å‡å° (åŸæ¥çº¦1.4)ï¼Œè§£å†³"å¤ªæ‰"çš„é—®é¢˜

            ctx.moveTo(cx, bottomTipY);

            // å·¦åŠè¾¹
            ctx.bezierCurveTo(
                cx - heartSize * widthFactor, cy + heartSize * 0.1,  // ä¾§è¾¹é¼“èµ·
                cx - heartSize * widthFactor, topY - heartSize * 0.5, // é¡¶éƒ¨åœ†å¼§
                cx, topY + heartSize * 0.15 // é¡¶éƒ¨å‡¹é™·
            );

            // å³åŠè¾¹
            ctx.bezierCurveTo(
                cx + heartSize * widthFactor, topY - heartSize * 0.5, // é¡¶éƒ¨åœ†å¼§
                cx + heartSize * widthFactor, cy + heartSize * 0.1,   // ä¾§è¾¹é¼“èµ·
                cx, bottomTipY
            );
            ctx.closePath();

            // ============ 2. ä¸»ä½“å¡«è‰² (ä¿æŒçº¢å®çŸ³è´¨æ„Ÿ) ============
            const mainGradient = ctx.createRadialGradient(
                cx + heartSize * 0.2, cy - heartSize * 0.3, heartSize * 0.1,
                cx, cy, heartSize * 1.3
            );
            mainGradient.addColorStop(0, '#FF4D6A');   // äº®éƒ¨
            mainGradient.addColorStop(0.3, '#E60026'); // ä¸­éƒ¨
            mainGradient.addColorStop(0.7, '#A8001C'); // æš—éƒ¨
            mainGradient.addColorStop(1, '#59000F');   // è¾¹ç¼˜

            ctx.fillStyle = mainGradient;
            ctx.fill();

            // ============ 3. å†…è¾¹ç¼˜å‘å…‰ ============
            ctx.save();
            ctx.strokeStyle = 'rgba(255, 120, 140, 0.3)';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            ctx.restore();

            // ============ 4. é«˜å…‰è°ƒæ•´ (é€‚é…æ–°å½¢çŠ¶) ============

            // å·¦ä¸Šå¤§é«˜å…‰ (æ›´ç˜¦é•¿)
            ctx.globalCompositeOperation = 'source-over';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.25)';
            ctx.beginPath();
            ctx.ellipse(
                cx - heartSize * 0.45, cy - heartSize * 0.45,
                heartSize * 0.22, heartSize * 0.12,
                Math.PI / 4, 0, Math.PI * 2
            );
            ctx.fill();

            // å·¦ä¸Šé”åˆ©é«˜å…‰
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.beginPath();
            ctx.ellipse(
                cx - heartSize * 0.5, cy - heartSize * 0.5,
                heartSize * 0.05, heartSize * 0.04,
                Math.PI / 4, 0, Math.PI * 2
            );
            ctx.fill();

            // å³ä¸Šè¾…åŠ©é«˜å…‰
            ctx.fillStyle = 'rgba(255, 200, 210, 0.15)';
            ctx.beginPath();
            ctx.ellipse(
                cx + heartSize * 0.35, cy - heartSize * 0.5,
                heartSize * 0.15, heartSize * 0.08,
                -Math.PI / 5, 0, Math.PI * 2
            );
            ctx.fill();

            // åº•éƒ¨åå…‰
            ctx.fillStyle = 'rgba(255, 180, 180, 0.3)';
            ctx.beginPath();
            ctx.ellipse(
                cx, cy + heartSize * 0.65,
                heartSize * 0.3, heartSize * 0.12,
                0, Math.PI, Math.PI * 2
            );
            ctx.fill();

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;

            return texture;
        }

        // ============ åˆ›å»ºèºæ—‹æ¡ƒå¿ƒè£…é¥°ï¼ˆå¸¦è·³åŠ¨æ•ˆæœï¼‰============
        function createSpiralHearts(config) {
            const {
                spiralCount = 4,
                startHeight = -2.0,
                endHeight = 6.0,
                radiusOffset = 0.4,
                phaseOffset = 0,
                elementCount = 80,
                elementSize = 0.7,
                heartTexture = null
            } = config;

            const positions = new Float32Array(elementCount * 3);
            const sizes = new Float32Array(elementCount);
            const phases = new Float32Array(elementCount);

            const treeBaseY = -2.5;
            const treeTopY = 6.5;
            const treeHeight = treeTopY - treeBaseY;
            const baseRadius = 3.5;

            for (let i = 0; i < elementCount; i++) {
                const i3 = i * 3;
                const t = i / (elementCount - 1);
                const y = startHeight + t * (endHeight - startHeight);
                const h = (y - treeBaseY) / treeHeight;
                const hClamped = Math.max(0, Math.min(1, h));
                const treeRadius = baseRadius * (1 - hClamped * 0.95);
                const angle = phaseOffset + t * spiralCount * Math.PI * 2;
                const finalRadius = treeRadius + radiusOffset;

                positions[i3] = Math.cos(angle) * finalRadius;
                positions[i3 + 1] = y;
                positions[i3 + 2] = Math.sin(angle) * finalRadius;

                sizes[i] = elementSize * (0.85 + Math.random() * 0.3);
                phases[i] = Math.random() * Math.PI * 2;
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('phase', new THREE.BufferAttribute(phases, 1));

            // ä»é…ç½®è¯»å–è·³åŠ¨å‚æ•°
            const beatSpeed = appConfig.ornament?.heartBeatSpeed || 1.5;
            const beatScale = appConfig.ornament?.heartBeatScale || 0.15;

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    pixelRatio: { value: renderer.getPixelRatio() },
                    heartTexture: { value: heartTexture },
                    beatSpeed: { value: beatSpeed },
                    beatScale: { value: beatScale }
                },
                vertexShader: `
                    attribute float size;
                    attribute float phase;
                    uniform float time;
                    uniform float pixelRatio;
                    uniform float beatSpeed;
                    uniform float beatScale;
                    varying float vAlpha;
                    
                    void main() {
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        
                        // å¿ƒè·³æ•ˆæœï¼šå‘¨æœŸæ€§æ”¾å¤§ç¼©å°
                        float beat = sin(time * beatSpeed * 3.14159 + phase) * 0.5 + 0.5;
                        float scale = 1.0 + beat * beatScale;
                        
                        vAlpha = 0.9 + beat * 0.1;
                        
                        gl_PointSize = size * scale * pixelRatio * 280.0 / -mvPosition.z;
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform sampler2D heartTexture;
                    varying float vAlpha;
                    
                    void main() {
                        // ç¿»è½¬Yåæ ‡
                        vec2 uv = vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y);
                        vec4 texColor = texture2D(heartTexture, uv);
                        
                        if (texColor.a < 0.1) discard;
                        
                        gl_FragColor = vec4(texColor.rgb, texColor.a * vAlpha);
                    }
                `,
                transparent: true,
                blending: THREE.NormalBlending,
                depthWrite: true,
                depthTest: true
            });

            return new THREE.Points(geometry, material);
        }

        // ============ åˆ›å»ºèºæ—‹é‡‘å¸è£…é¥° ============
        function createSpiralCoins(config) {
            const {
                spiralCount = 4,           // ç¯ç»•åœˆæ•°
                startHeight = -2.0,        // èµ·å§‹é«˜åº¦
                endHeight = 6.0,           // ç»“æŸé«˜åº¦
                radiusOffset = 0.4,        // ç›¸å¯¹æ ‘è¡¨é¢çš„åç§»
                phaseOffset = 0,           // ç›¸ä½åç§»ï¼ˆå¼§åº¦ï¼‰
                elementCount = 80,         // å…ƒç´ æ•°é‡
                elementSize = 1,         // å…ƒç´ å¤§å°ï¼ˆå¢å¤§ä»¥æ˜¾ç¤ºçº¹ç†ç»†èŠ‚ï¼‰
                coinTexture = null         // çº¹ç†
            } = config;

            const positions = new Float32Array(elementCount * 3);
            const sizes = new Float32Array(elementCount);
            const phases = new Float32Array(elementCount);  // ç”¨äºé—ªçƒ

            // æ ‘çš„å‡ ä½•å‚æ•°ï¼ˆä»createTreeParticlesåˆ†æå¾—å‡ºï¼‰
            const treeBaseY = -2.5;
            const treeTopY = 6.5;
            const treeHeight = treeTopY - treeBaseY;  // 9
            const baseRadius = 3.5;

            for (let i = 0; i < elementCount; i++) {
                const i3 = i * 3;

                // t ä» 0 åˆ° 1ï¼Œä»£è¡¨æ²¿èºæ—‹è·¯å¾„çš„è¿›åº¦
                const t = i / (elementCount - 1);

                // è®¡ç®—é«˜åº¦
                const y = startHeight + t * (endHeight - startHeight);

                // æ ¹æ®é«˜åº¦è®¡ç®—æ ‘åœ¨è¯¥ä½ç½®çš„åŠå¾„
                // h æ˜¯å½’ä¸€åŒ–é«˜åº¦ (0=åº•éƒ¨, 1=é¡¶éƒ¨)
                const h = (y - treeBaseY) / treeHeight;
                const hClamped = Math.max(0, Math.min(1, h));
                const treeRadius = baseRadius * (1 - hClamped * 0.95);

                // èºæ—‹è§’åº¦
                const angle = phaseOffset + t * spiralCount * Math.PI * 2;

                // æœ€ç»ˆåŠå¾„ = æ ‘åŠå¾„ + åç§»
                const finalRadius = treeRadius + radiusOffset;

                // è®¡ç®—ä½ç½®
                positions[i3] = Math.cos(angle) * finalRadius;
                positions[i3 + 1] = y;
                positions[i3 + 2] = Math.sin(angle) * finalRadius;

                // å¤§å°æœ‰è½»å¾®å˜åŒ–
                sizes[i] = elementSize * (0.85 + Math.random() * 0.3);

                // éšæœºç›¸ä½ç”¨äºé—ªçƒ
                phases[i] = Math.random() * Math.PI * 2;
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('phase', new THREE.BufferAttribute(phases, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    pixelRatio: { value: renderer.getPixelRatio() },
                    coinTexture: { value: coinTexture }
                },
                vertexShader: `
                    attribute float size;
                    attribute float phase;
                    uniform float time;
                    uniform float pixelRatio;
                    varying float vAlpha;
                    varying float vBrightness;
                    
                    // ä¼ªéšæœºå‡½æ•°
                    float rand(float n) {
                        return fract(sin(n * 12.9898) * 43758.5453);
                    }
                    
                    void main() {
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        
                        // é—ªçƒæ•ˆæœï¼šå¤šå±‚éšæœº + å‘¼å¸
                        float t = time + phase * 100.0;
                        float r1 = rand(floor(t * 1.5 + phase * 13.0));
                        float r2 = rand(floor(t * 4.0 + phase * 23.0));
                        float breathe = sin(t * 0.8 + phase) * 0.5 + 0.5;
                        float sparkle = step(0.92, r2);  // 8%æ¦‚ç‡çªç„¶æ›´äº®
                        
                        vBrightness = 0.7 + 0.2 * r1 + 0.15 * breathe + 0.4 * sparkle;
                        vAlpha = 0.85 + 0.15 * breathe;
                        
                        gl_PointSize = size * pixelRatio * 280.0 / -mvPosition.z;
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform sampler2D coinTexture;
                    varying float vAlpha;
                    varying float vBrightness;
                    
                    void main() {
                        // ç¿»è½¬Yåæ ‡ä½¿å›¾æ¡ˆæ­£å‘
                        vec2 uv = vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y);
                        vec4 texColor = texture2D(coinTexture, uv);
                        
                        // ä¸¢å¼ƒé€æ˜åƒç´ 
                        if (texColor.a < 0.1) discard;
                        
                        // åº”ç”¨äº®åº¦è°ƒåˆ¶ï¼ˆé—ªé—ªå‘å…‰æ•ˆæœï¼‰
                        vec3 finalColor = texColor.rgb * vBrightness;
                        
                        // é—ªå…‰æ—¶æ·»åŠ ç™½è‰²é«˜å…‰
                        finalColor = mix(finalColor, vec3(1.0, 0.95, 0.7), (vBrightness - 1.0) * 0.5);
                        
                        gl_FragColor = vec4(finalColor, texColor.a);
                    }
                `,
                transparent: true,
                blending: THREE.NormalBlending,
                depthWrite: true,
                depthTest: true
            });

            return new THREE.Points(geometry, material);
        }

        // åˆ›å»ºé‡‘å¸çº¹ç†ï¼ˆä»éšè—çš„imgæ ‡ç­¾åŠ è½½ï¼Œå¸¦å¼‚æ­¥ç­‰å¾…ï¼‰
        let goldCoinTexture = createGoldCoinTexture();  // å…ˆç”¨Canvaså¤‡ç”¨
        let heartTexture = createHeartTexture();  // æ¡ƒå¿ƒçº¹ç†
        let spiralOrnamentMeshes = [];

        // åˆ›å»ºèºæ—‹è£…é¥°å¸¦é…ç½®
        const spiralOrnamentGroup = new THREE.Group();
        const spiralConfigs = [
            { phaseOffset: 0, spiralCount: 3.5, elementCount: 70 },
            { phaseOffset: Math.PI / 2, spiralCount: 3.5, elementCount: 70 },
            { phaseOffset: Math.PI, spiralCount: 3.5, elementCount: 70 },
            { phaseOffset: Math.PI * 3 / 2, spiralCount: 3.5, elementCount: 70 }
        ];

        // åˆå§‹åŒ–è£…é¥°ç‰©ï¼ˆæ ¹æ®é…ç½®é€‰æ‹©ç±»å‹ï¼‰
        function initSpiralOrnaments() {
            const ornamentConfig = appConfig.ornament || { enabled: true, type: 'coin' };

            // æ¸…ç©ºæ—§çš„
            while (spiralOrnamentGroup.children.length > 0) {
                spiralOrnamentGroup.remove(spiralOrnamentGroup.children[0]);
            }
            spiralOrnamentMeshes = [];

            // å¦‚æœç¦ç”¨åˆ™ä¸åˆ›å»º
            if (!ornamentConfig.enabled) {
                console.log('ğŸ„ è£…é¥°ç‰©å·²ç¦ç”¨');
                return;
            }

            const ornamentType = ornamentConfig.type || 'coin';
            console.log(`ğŸ„ åˆå§‹åŒ–è£…é¥°ç‰©: ${ornamentType}`);

            spiralOrnamentMeshes = spiralConfigs.map(cfg => {
                let ornament;
                if (ornamentType === 'heart') {
                    ornament = createSpiralHearts({
                        ...cfg,
                        startHeight: -1.8,
                        endHeight: 5.8,
                        radiusOffset: 0.2,
                        elementSize: 1.1, // Reduced for balance
                        heartTexture: heartTexture
                    });
                } else {
                    // é»˜è®¤é‡‘å¸
                    ornament = createSpiralCoins({
                        ...cfg,
                        startHeight: -1.8,
                        endHeight: 5.8,
                        radiusOffset: 0.2,
                        elementSize: 0.85,
                        coinTexture: goldCoinTexture
                    });
                }
                spiralOrnamentGroup.add(ornament);
                return ornament;
            });
        }

        // å…¼å®¹æ—§çš„å‡½æ•°å
        function initSpiralCoins(texture) {
            goldCoinTexture = texture;
            if (appConfig.ornament?.type === 'coin') {
                initSpiralOrnaments();
            }
        }

        // å…ˆåˆå§‹åŒ–è£…é¥°ç‰©
        initSpiralOrnaments();

        // æš´éœ²åˆ°å…¨å±€ï¼ˆä¾›æŒ‰é’®è°ƒç”¨ï¼‰
        window.initSpiralOrnaments = initSpiralOrnaments;

        // å¼‚æ­¥åŠ è½½PNGçº¹ç†
        function loadPNGTexture() {
            const img = document.getElementById('coin-texture-img');
            if (!img) {
                console.warn('âš ï¸ æ‰¾ä¸åˆ°imgæ ‡ç­¾ï¼Œä½¿ç”¨Canvasçº¹ç†');
                return;
            }

            function onImgLoad() {
                console.log('âœ… PNGé‡‘å¸çº¹ç†åŠ è½½æˆåŠŸï¼Œå°ºå¯¸:', img.naturalWidth, 'x', img.naturalHeight);
                goldCoinTexture = new THREE.Texture(img);
                goldCoinTexture.needsUpdate = true;
                // å¦‚æœå½“å‰æ˜¯é‡‘å¸æ¨¡å¼ï¼Œé‡æ–°åˆ›å»º
                if (appConfig.ornament?.type === 'coin' || !appConfig.ornament?.type) {
                    initSpiralOrnaments();
                }
            }

            if (img.complete && img.naturalWidth > 0) {
                onImgLoad();
            } else {
                img.onload = onImgLoad;
                img.onerror = () => console.warn('âŒ PNGåŠ è½½å¤±è´¥ï¼Œä¿æŒCanvasçº¹ç†');
            }
        }

        // å°è¯•åŠ è½½PNG
        setTimeout(loadPNGTexture, 100);

        // ============ æ·»åŠ åˆ°åœºæ™¯ ============
        const treeParticles = createTreeParticles();
        const groundParticles = createGroundParticles();
        const stars = createStars();
        const topStar = createTopStar();
        const twinklingLights = createTwinklingLights();  // é—ªçƒç¯ä¸²
        const floatingSnow = createFloatingSnow();
        const snowflakes = createSnowflakes();

        scene.add(stars);
        scene.add(groundParticles);
        scene.add(treeParticles);
        scene.add(topStar);
        scene.add(twinklingLights);  // é—ªçƒç¯ä¸²
        scene.add(spiralOrnamentGroup);  // èºæ—‹è£…é¥°ç‰©ï¼ˆé‡‘å¸æˆ–æ¡ƒå¿ƒï¼‰

        // é›ªèŠ±æ·»åŠ åˆ°æ‘„åƒå¤´ä¸Šï¼Œä½¿å…¶å§‹ç»ˆåœ¨æ‘„åƒå¤´å‰æ–¹ï¼Œä¸å—è§†è§’æ—‹è½¬å½±å“
        camera.add(floatingSnow);
        camera.add(snowflakes);
        scene.add(camera); // éœ€è¦æŠŠæ‘„åƒå¤´æ·»åŠ åˆ°åœºæ™¯æ‰èƒ½æ¸²æŸ“å…¶å­å¯¹è±¡

        // ============ åŠ¨ç”» ============
        let time = 0;

        function animate() {
            requestAnimationFrame(animate);

            time += 0.016;

            // æ¯ä¸€å¸§å°è¯•å½•åˆ¶
            recordFrame();

            // å›æ”¾å½•åˆ¶æ•°æ®
            if (isPlayingRecording) {
                playbackFrame++; // æ’­æ”¾ä¸‹ä¸€å¸§
                if (playbackFrame < recordedFrames.length) {
                    const f = recordedFrames[playbackFrame];
                    camera.position.set(f.px, f.py, f.pz);
                    controls.target.set(f.tx, f.ty, f.tz); // åŒæ­¥æ›´æ–°ç›®æ ‡ç‚¹
                    controls.update();
                } else {
                    // å›æ”¾ç»“æŸ
                    isPlayingRecording = false;
                    controls.enabled = true;
                    console.log('ğŸ“¼ å½•åˆ¶å›æ”¾ç»“æŸ');
                    document.querySelector('.text-overlay').classList.remove('hidden');
                }
            }

            // æ‘„åƒå¤´åŠ¨ç”» (å‚æ•°æ’å€¼)
            if (cameraAnimating) {
                cameraAnimProgress += 0.016 / animParams.duration;

                if (cameraAnimProgress >= 1) {
                    cameraAnimProgress = 1;
                    cameraAnimating = false;
                    controls.enabled = true;  // å¯ç”¨æ§ä»¶

                    console.log('[åŠ¨ç”»] å®Œæˆ! controls.enabled =', controls.enabled);

                    // æ˜¾ç¤ºæ–‡å­—
                    document.querySelector('.text-overlay').classList.remove('hidden');
                }

                const t = getEasing(cameraAnimProgress);

                // ç›®æ ‡ç‚¹åŠ¨ç”»ï¼ˆçº¿æ€§æ’å€¼å³å¯ï¼‰
                const targetX = animParams.targetStartX + (animParams.targetEndX - animParams.targetStartX) * t;
                const targetY = animParams.targetStartY + (animParams.targetEndY - animParams.targetStartY) * t;
                const targetZ = animParams.targetStartZ + (animParams.targetEndZ - animParams.targetStartZ) * t;
                controls.target.set(targetX, targetY, targetZ);

                // æ‘„åƒå¤´ä½ç½®åŠ¨ç”»ï¼šä½¿ç”¨çƒé¢æ’å€¼
                const startSpherical = cartesianToSpherical(
                    animParams.startX, animParams.startY, animParams.startZ,
                    animParams.targetStartX, animParams.targetStartY, animParams.targetStartZ
                );
                const endSpherical = cartesianToSpherical(
                    animParams.endX, animParams.endY, animParams.endZ,
                    animParams.targetEndX, animParams.targetEndY, animParams.targetEndZ
                );

                // åœ¨æåæ ‡ç©ºé—´æ’å€¼
                const r = startSpherical.r + (endSpherical.r - startSpherical.r) * t;
                const theta = startSpherical.theta + (endSpherical.theta - startSpherical.theta) * t;
                const phi = startSpherical.phi + (endSpherical.phi - startSpherical.phi) * t;

                // è½¬å›ç¬›å¡å°”åæ ‡
                const pos = sphericalToCartesian(r, theta, phi, targetX, targetY, targetZ);
                camera.position.set(pos.x, pos.y, pos.z);

                controls.update();
            }

            controls.update();

            // æ›´æ–°ç€è‰²å™¨ uniform
            treeParticles.material.uniforms.time.value = time;
            groundParticles.material.uniforms.time.value = time;
            stars.material.uniforms.time.value = time;
            topStar.material.uniforms.time.value = time;
            twinklingLights.material.uniforms.time.value = time;  // é—ªçƒç¯ä¸²
            spiralOrnamentMeshes.forEach(mesh => mesh.material.uniforms.time.value = time);  // èºæ—‹è£…é¥°ç‰©

            // æ›´æ–°è°ƒè¯•ä¿¡æ¯
            const debugEl = document.getElementById('debug-info');
            if (debugEl.style.display !== 'none') {
                const pos = camera.position;
                const target = controls.target;
                const dx = pos.x - target.x;
                const dy = pos.y - target.y;
                const dz = pos.z - target.z;
                const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                const azimuth = Math.atan2(dx, dz) * 180 / Math.PI;
                const elevation = Math.asin(dy / dist) * 180 / Math.PI;
                document.getElementById('camera-info').innerHTML = `
                    <b>ğŸ“ æ‘„åƒå¤´ä½ç½®</b><br>
                    X: ${pos.x.toFixed(2)}<br>
                    Y: ${pos.y.toFixed(2)}<br>
                    Z: ${pos.z.toFixed(2)}<br>
                    <br>
                    <b>ğŸ¯ æåæ ‡</b><br>
                    è·ç¦»: ${dist.toFixed(2)}<br>
                    æ°´å¹³è§’: ${azimuth.toFixed(1)}Â°<br>
                    ä»°è§’: ${elevation.toFixed(1)}Â°
                `;
            }

            // æ›´æ–°æ¼‚æµ®é›ªçƒä½ç½®
            const floatPos = floatingSnow.geometry.attributes.position.array;
            const floatVel = floatingSnow.userData.velocities;
            for (let i = 0; i < FLOATING_SNOW_COUNT; i++) {
                const i3 = i * 3;
                const vel = floatVel[i];

                floatPos[i3 + 1] -= vel.y * 0.016;
                floatPos[i3] += Math.sin(time * 0.5 + vel.phase) * vel.swayX * 0.016;
                floatPos[i3 + 2] += Math.cos(time * 0.4 + vel.phase) * vel.swayZ * 0.016;

                // å¾ªç¯ (æ‘„åƒå¤´æœ¬åœ°åæ ‡)
                if (floatPos[i3 + 1] < -10) {
                    floatPos[i3 + 1] = 12;
                    floatPos[i3] = (Math.random() - 0.5) * 30;
                    floatPos[i3 + 2] = -5 - Math.random() * 25;
                }
            }
            floatingSnow.geometry.attributes.position.needsUpdate = true;

            // æ›´æ–°é£å‘ï¼ˆå¹³æ»‘è¿‡æ¸¡ï¼‰
            defaultWindPhase += 0.003;
            // é»˜è®¤é£å‘ç¼“æ…¢å˜åŒ–
            const defaultWindX = Math.sin(defaultWindPhase) * 0.8;
            const defaultWindZ = Math.cos(defaultWindPhase * 0.7) * 0.3;

            // ç›®æ ‡é£å‘æ…¢æ…¢å›å½’é»˜è®¤
            targetWindX = targetWindX * 0.98 + defaultWindX * 0.02;
            targetWindZ = targetWindZ * 0.98 + defaultWindZ * 0.02;

            // å½“å‰é£å‘å¹³æ»‘è¿½éšç›®æ ‡
            windX += (targetWindX - windX) * 0.05;
            windZ += (targetWindZ - windZ) * 0.05;

            // æ›´æ–°å…­è§’é›ªèŠ±ä½ç½®ï¼ˆå—é£å‘å½±å“ï¼‰
            const snowPos = snowflakes.geometry.attributes.position.array;
            const snowVel = snowflakes.userData.velocities;
            for (let i = 0; i < SNOWFLAKE_COUNT; i++) {
                const i3 = i * 3;
                const vel = snowVel[i];

                // ä¸‹è½ + é£å‘å½±å“ + å°å¹…æ‘†åŠ¨
                snowPos[i3 + 1] -= vel.y * 0.016;
                snowPos[i3] += (windX + Math.sin(time * 0.8 + vel.phase) * vel.swayAmp) * 0.016;
                snowPos[i3 + 2] += (windZ + Math.cos(time * 0.6 + vel.phase) * vel.swayAmp * 0.5) * 0.016;

                // å¾ªç¯ (æ‘„åƒå¤´æœ¬åœ°åæ ‡)
                if (snowPos[i3 + 1] < -10) {
                    snowPos[i3 + 1] = 12;
                    snowPos[i3] = (Math.random() - 0.5) * 25;
                    snowPos[i3 + 2] = -3 - Math.random() * 20;
                }
            }
            snowflakes.geometry.attributes.position.needsUpdate = true;

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // æŒ‰ ` é”®åˆ‡æ¢è°ƒè¯•é¢æ¿
        window.addEventListener('keydown', (e) => {
            if (e.key === '`') {
                const debugEl = document.getElementById('debug-info');
                debugEl.style.display = debugEl.style.display === 'none' ? 'block' : 'none';
            }
        });

        animate();

        // Export functions to window for HTML access
        window.configManager = configManager;
        window.setStartToCurrent = setStartToCurrent;
        window.setEndToCurrent = setEndToCurrent;
        window.replayAnimation = replayAnimation;
        window.saveAnimationToLocal = saveAnimationToLocal;
        window.applyTextConfig = applyTextConfig;
        window.saveTextToLocal = saveTextToLocal;

    </script>

    <!-- æ ·å¼ (æ”¾åœ¨scriptåé¢ï¼Œç¡®ä¿åœ¨bodyæ¸²æŸ“å‰è§£æ) -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: 'Times New Roman', Georgia, serif;
        }

        #container {
            width: 100vw;
            height: 100vh;
        }

        .text-overlay {
            position: fixed;
            left: 8%;
            top: 38%;
            pointer-events: none;
            z-index: 10;
        }

        .text-overlay h1 {
            font-size: clamp(32px, 5vw, 56px);
            font-style: italic;
            font-weight: normal;
            color: rgba(255, 255, 255, 0.9);
            text-shadow:
                0 0 30px rgba(255, 255, 255, 0.4),
                0 0 60px rgba(255, 200, 220, 0.2);
            margin-bottom: 12px;
            animation: float 4s ease-in-out infinite;
        }

        .text-overlay p {
            font-size: clamp(20px, 3vw, 32px);
            font-family: 'KaiTi', 'æ¥·ä½“', 'STKaiti', serif;
            color: rgba(255, 210, 225, 0.85);
            text-shadow:
                0 0 20px rgba(255, 150, 180, 0.4),
                0 0 40px rgba(255, 100, 150, 0.2);
            animation: float 4s ease-in-out infinite 0.5s;
        }

        @keyframes float {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-6px);
            }
        }

        /* å¼€åœºè¦†ç›–å±‚ */
        #intro-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }

        /* å‘¼å¸å…‰åœˆ */
        .breath-ring {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            animation: breathe 2s ease-in-out infinite;
            position: relative;
        }

        .breath-ring::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            animation: breathe 2s ease-in-out infinite;
        }

        .breath-ring::after {
            content: '';
            position: absolute;
            top: -20px;
            left: -20px;
            right: -20px;
            bottom: -20px;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.15);
            animation: breathe 2s ease-in-out infinite 0.3s;
        }

        @keyframes breathe {

            0%,
            100% {
                transform: scale(1);
                opacity: 0.3;
            }

            50% {
                transform: scale(1.2);
                opacity: 0.8;
            }
        }

        .breath-ring::before {
            animation: breathe-inner 2s ease-in-out infinite;
        }

        @keyframes breathe-inner {

            0%,
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.4;
            }

            50% {
                transform: translate(-50%, -50%) scale(1.3);
                opacity: 1;
            }
        }

        /* æ–‡å­—åˆå§‹éšè— */
        .text-overlay.hidden {
            opacity: 0;
        }

        .text-overlay {
            transition: opacity 1.5s ease-in-out;
        }

        /* å½•åˆ¶æŒ‡ç¤ºå™¨ */
        @keyframes blink {
            50% {
                opacity: 0.5;
            }
        }

        .rec-ready {
            color: #ffff00;
            border: 1px solid #ffff00;
        }

        .rec-recording {
            color: #ff0000;
            border: 1px solid #ff0000;
            animation: blink 1s infinite;
        }

        .rec-saved {
            color: #00ff00;
            border: 1px solid #00ff00;
        }

        /* å½•åˆ¶æŒ‡ç¤ºå™¨é»˜è®¤æ ·å¼æ›´æ–° */
        #rec-indicator {
            position: fixed;
            top: 20px;
            left: 20px;
            font-weight: bold;
            font-family: monospace;
            z-index: 2000;
            font-size: 16px;
            display: none;
            pointer-events: none;
            padding: 5px 10px;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.5);
        }


        /* è°ƒè¯•é¢æ¿æ ·å¼ */
        #debug-info {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 300px;
            max-height: 90vh;
            overflow-y: auto;
            background: rgba(18, 18, 24, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            color: #e0e0e0;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 13px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: none;
            /* JSæ§åˆ¶ */
        }

        /* æ»šåŠ¨æ¡ç¾åŒ– */
        #debug-info::-webkit-scrollbar {
            width: 6px;
        }

        #debug-info::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
        }

        #debug-info::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        .panel-section {
            margin-bottom: 20px;
        }

        .section-title {
            font-weight: 600;
            color: #fff;
            margin-bottom: 10px;
            font-size: 14px;
            border-left: 3px solid #06a;
            padding-left: 8px;
        }

        .control-group {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            justify-content: space-between;
        }

        .control-group label {
            color: #aaa;
            flex: 0 0 60px;
        }

        .control-group input[type="number"],
        .control-group input[type="text"],
        .control-group select {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #444;
            color: #0f0;
            padding: 4px 8px;
            border-radius: 4px;
            flex: 1;
            outline: none;
            transition: border-color 0.2s;
        }

        .control-group input:focus,
        .control-group select:focus {
            border-color: #06a;
        }

        .control-row {
            display: flex;
            gap: 10px;
            margin-bottom: 8px;
        }

        .control-group.half {
            flex: 1;
            margin-bottom: 0;
        }

        .control-group.half label {
            flex: 0 0 35px;
        }

        .btn-group {
            display: flex;
            gap: 8px;
        }

        .btn {
            flex: 1;
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s;
            text-align: center;
            color: #fff;
            display: inline-block;
        }

        .btn:hover {
            filter: brightness(1.1);
            transform: translateY(-1px);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-primary {
            background: linear-gradient(135deg, #0a0, #080);
            color: #fff;
        }

        .btn-action {
            background: linear-gradient(135deg, #06a, #048);
            color: #fff;
        }

        .btn-danger {
            background: linear-gradient(135deg, #a33, #822);
            color: #fff;
        }

        .btn-secondary {
            background: #333;
            border: 1px solid #555;
            color: #ccc;
        }

        .btn-sm {
            flex: 0 0 auto;
            padding: 4px 8px;
            font-size: 11px;
            margin-left: 5px;
            background: #444;
            color: #ccc;
        }

        .divider {
            height: 1px;
            background: #333;
            margin: 10px 0;
        }

        .text-line-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 10px;
        }

        .card-header {
            font-size: 11px;
            color: #fc0;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .full-width {
            width: 100%;
            box-sizing: border-box;
            margin-bottom: 5px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #444;
            color: #fff;
            padding: 5px;
            border-radius: 4px;
        }

        kbd {
            background: #444;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            border-bottom: 2px solid #222;
        }

        .hint-text {
            color: #888;
            font-size: 12px;
        }

        /* Optimize Layout */
        #debug-info {
            box-sizing: border-box;
            width: 300px !important;
            /* Force width */
        }

        .control-header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding-right: 2px;
        }

        .label-title {
            color: #ccc;
            font-size: 12px;
            font-weight: bold;
        }

        /* Make inputs in Animation section tighter */
        .panel-section .control-group label {
            flex: 0 0 50px;
            /* Slightly reduce label width */
        }
    </style>
</head>

<body>
    <!-- éšè—çš„å›¾ç‰‡èµ„æºï¼ˆç”¨äºçº¹ç†åŠ è½½ï¼Œç»•è¿‡CORSé™åˆ¶ï¼‰ -->
    <img id="coin-texture-img" src="png/g1.png" style="display:none" crossorigin="anonymous">

    <div id="container"></div>
    <div class="text-overlay hidden">
        <!-- Content will be populated by JS now -->
    </div>

    <!-- å¼€åœºè¦†ç›–å±‚ -->
    <div id="intro-overlay">
        <div class="breath-ring"></div>
    </div>

    <!-- å½•åˆ¶æŒ‡ç¤ºå™¨ -->
    <div id="rec-indicator">â— REC</div>

    <!-- è°ƒè¯•é¢æ¿ (æŒ‰` é”®åˆ‡æ¢) -->
    <div id="debug-info">
        <div id="camera-info"></div>

        <div class="panel-section">
            <div class="section-title">ğŸ’¾ é…ç½®ç®¡ç†</div>
            <div class="btn-group">
                <button onclick="configManager.reset()" class="btn btn-danger">é‡ç½®</button>
            </div>
            <div class="btn-group">
                <button onclick="configManager.export()" class="btn btn-secondary">å¯¼å‡ºJSON</button>
                <label class="btn btn-secondary">
                    å¯¼å…¥JSON
                    <input type="file" onchange="configManager.import(this)" style="display:none;" accept=".json">
                </label>
            </div>
        </div>

        <div class="panel-section">
            <div class="section-title">ğŸ¬ åŠ¨ç”»å‚æ•°</div>

            <div class="control-header-row">
                <span class="label-title">åŠ¨ç”»èµ·ç‚¹</span>
                <button onclick="setStartToCurrent()" class="btn btn-sm">å†™å…¥å½“å‰</button>
            </div>
            <div class="control-group">
                <label>X:</label>
                <input type="number" id="anim-start-x" step="0.1">
            </div>
            <div class="control-group">
                <label>Y:</label>
                <input type="number" id="anim-start-y" step="0.1">
            </div>
            <div class="control-group">
                <label>Z:</label>
                <input type="number" id="anim-start-z" step="0.1">
            </div>

            <div class="divider"></div>

            <div class="control-header-row">
                <span class="label-title">åŠ¨ç”»ç»ˆç‚¹</span>
                <button onclick="setEndToCurrent()" class="btn btn-sm">å†™å…¥å½“å‰</button>
            </div>
            <div class="control-group">
                <label>X:</label>
                <input type="number" id="anim-end-x" step="0.1">
            </div>
            <div class="control-group">
                <label>Y:</label>
                <input type="number" id="anim-end-y" step="0.1">
            </div>
            <div class="control-group">
                <label>Z:</label>
                <input type="number" id="anim-end-z" step="0.1">
            </div>
        </div>

        <div class="panel-section">
            <div class="section-title">ğŸ¯ ç›®æ ‡ç‚¹ (æ—‹è½¬ä¸­å¿ƒ)</div>

            <div class="control-header-row">
                <span class="label-title">ç›®æ ‡èµ·ç‚¹</span>
            </div>
            <div class="control-group">
                <label>X:</label>
                <input type="number" id="anim-target-start-x" step="0.1">
            </div>
            <div class="control-group">
                <label>Y:</label>
                <input type="number" id="anim-target-start-y" step="0.1">
            </div>
            <div class="control-group">
                <label>Z:</label>
                <input type="number" id="anim-target-start-z" step="0.1">
            </div>

            <div class="divider"></div>

            <div class="control-header-row">
                <span class="label-title">ç›®æ ‡ç»ˆç‚¹</span>
            </div>
            <div class="control-group">
                <label>X:</label>
                <input type="number" id="anim-target-end-x" step="0.1">
            </div>
            <div class="control-group">
                <label>Y:</label>
                <input type="number" id="anim-target-end-y" step="0.1">
            </div>
            <div class="control-group">
                <label>Z:</label>
                <input type="number" id="anim-target-end-z" step="0.1">
            </div>
        </div>

        <div class="panel-section">
            <div class="control-group">
                <label>æ—¶é•¿(ç§’):</label>
                <input type="number" id="anim-duration" step="0.1" min="0.5" max="10">
            </div>
            <div class="control-group">
                <label>ç¼“åŠ¨:</label>
                <select id="anim-easing">
                    <option value="linear">Linear</option>
                    <option value="easeOut" selected>Ease Out</option>
                    <option value="easeIn">Ease In</option>
                    <option value="easeInOut">Ease In Out</option>
                </select>
            </div>

            <div class="btn-group" style="margin-top:10px;">
                <button onclick="replayAnimation()" class="btn btn-primary">â–¶ é‡æ’­åŠ¨ç”»</button>
                <button onclick="saveAnimationToLocal()" class="btn btn-action">ğŸ’¾ ä¿å­˜é…ç½®</button>
            </div>
        </div>

        <div class="panel-section">
            <div class="section-title">ğŸ¥ å½•åˆ¶åŠ¨ç”»</div>
            <div class="hint-text">æŒ‰ <kbd>R</kbd> å½•åˆ¶ / <kbd>P</kbd> å›æ”¾</div>
            <div id="record-status" style="color:#f00; margin-top:5px; height:18px;"></div>
        </div>

        <div class="panel-section">
            <div class="section-title">ğŸ„ æ ‘ä¸Šè£…é¥°ç‰©</div>
            <div class="control-group">
                <label>æ˜¾ç¤º:</label>
                <input type="checkbox" id="ornament-enabled" checked onchange="onOrnamentConfigChange()">
            </div>
            <div class="control-group">
                <label>ç±»å‹:</label>
                <select id="ornament-type" onchange="onOrnamentConfigChange()">
                    <option value="coin">ğŸ’° é‡‘å¸</option>
                    <option value="heart">â¤ï¸ æ¡ƒå¿ƒ</option>
                </select>
            </div>
            <div id="heart-options" style="display:none;">
                <div class="control-group">
                    <label>è·³åŠ¨é€Ÿåº¦:</label>
                    <input type="number" id="heart-beat-speed" step="0.1" min="0.5" max="5" value="1.5"
                        onchange="onOrnamentConfigChange()">
                </div>
                <div class="control-group">
                    <label>è·³åŠ¨å¹…åº¦:</label>
                    <input type="number" id="heart-beat-scale" step="0.05" min="0" max="0.5" value="0.15"
                        onchange="onOrnamentConfigChange()">
                </div>
            </div>
            <div class="btn-group" style="margin-top:10px;">
                <button onclick="applyOrnamentConfig()" class="btn btn-action">âœ¨ åº”ç”¨è£…é¥°</button>
                <button onclick="saveOrnamentToLocal()" class="btn btn-action">ğŸ’¾ ä¿å­˜é…ç½®</button>
            </div>
        </div>

        <div class="panel-section">
            <div class="section-title">ğŸ“ æ–‡å­—é…ç½®</div>

            <div class="control-group">
                <label>Left:</label>
                <input type="text" id="text-left">
            </div>
            <div class="control-group">
                <label>Top:</label>
                <input type="text" id="text-top">
            </div>

            <div id="text-lines-config">
                <div class="text-line-card" data-line="0">
                    <div class="card-header">è¡Œ 1</div>
                    <input type="text" id="text-content-0" class="full-width" placeholder="å†…å®¹">
                    <div class="control-row">
                        <input type="text" id="text-size-0" placeholder="Size" style="width:40%">
                        <input type="text" id="text-color-0" placeholder="Color" style="width:40%">
                        <input type="checkbox" id="text-italic-0" title="æ–œä½“">
                    </div>
                    <select id="text-font-0" class="full-width">
                        <option value="serif" selected>è¡¬çº¿ä½“ (Serif)</option>
                        <option value="sans-serif">æ— è¡¬çº¿ (Sans)</option>
                        <option value="KaiTi">æ¥·ä½“</option>
                    </select>
                </div>

                <div class="text-line-card" data-line="1">
                    <div class="card-header">è¡Œ 2</div>
                    <input type="text" id="text-content-1" class="full-width" placeholder="å†…å®¹">
                    <div class="control-row">
                        <input type="text" id="text-size-1" placeholder="Size" style="width:40%">
                        <input type="text" id="text-color-1" placeholder="Color" style="width:40%">
                        <input type="checkbox" id="text-italic-1" title="æ–œä½“">
                    </div>
                    <select id="text-font-1" class="full-width">
                        <option value="serif">è¡¬çº¿ä½“ (Serif)</option>
                        <option value="sans-serif">æ— è¡¬çº¿ (Sans)</option>
                        <option value="KaiTi">æ¥·ä½“</option>
                    </select>
                </div>
            </div>

            <div class="btn-group" style="margin-top:15px;">
                <button onclick="applyTextConfig()" class="btn btn-action">âœï¸ åº”ç”¨æ–‡å­—</button>
                <button onclick="saveTextToLocal()" class="btn btn-action">ğŸ’¾ ä¿å­˜é…ç½®</button>
            </div>
        </div>
    </div>

    <div class="panel-section">
        <div class="section-title">â„¹ï¸ å…³äºä½œè€…</div>
        <div class="control-group" style="margin-bottom: 5px;">
            <label style="width: 60px;">äº¤æµç¾¤:</label>
            <!-- é“¾æ¥åˆ° QQ åŠ ç¾¤ (å¦‚æœç”¨æˆ·æœ‰å®‰è£… QQ) -->
            <a href="tencent://groupwpa/?subcmd=all&param=7B2267726F7570556964223A3939333937353334397D"
                style="color: #4da6ff; text-decoration: none; align-self: center;">
                993975349
            </a>
        </div>
        <div class="control-group">
            <label style="width: 60px;">GitHub:</label>
            <a href="https://github.com/YourUsername/GalaxyTree" target="_blank"
                style="color: #4da6ff; text-decoration: none; align-self: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 180px;">
                GalaxyTree Repo
            </a>
        </div>
    </div>
    </div>



    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

</body>

</html>